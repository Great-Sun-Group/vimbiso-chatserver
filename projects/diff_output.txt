# Use this command from a codespace environment to create a merge commit with a detailed summary according to best practices from the following diff
# gh pr create --base $to_branch --head $from_branch --title "Merge $from_branch into $to_branch" --body "[detailed summary here]"

Changes detected between deploy104 and dev branches.

Changed files:
.devcontainer/devcontainer.json
.env.example
.flake8
.github/workflows/app.yml
.github/workflows/connectors.yml
DEPLOYMENT.md
Dockerfile
LICENSE
README.Docker.md
README.md
app/compose.yaml
app/config/asgi.py
app/config/settings.py
app/config/urls.py
app/config/wsgi.py
app/core/__init__.py
app/core/api/api_interactions.py
app/core/api/models.py
app/core/api/services.py
app/core/api/tests.py
app/core/api/views.py
app/core/config/apps.py
app/core/config/constants.py
app/core/message_handling/action_handlers.py
app/core/message_handling/credex_bot_service.py
app/core/message_handling/message_handling.py
app/core/message_handling/offer_credex_handler.py
app/core/message_handling/router.py
app/core/message_handling/screens.py
app/core/message_handling/whatsapp_forms.py
app/core/migrations/0001_initial.py
app/core/migrations/0002_message_last_updated.py
app/core/state/state_management.py
app/core/utils/audit_logging.py
app/core/utils/credex_bot_utils.py
app/core/utils/error_handler.py
app/core/utils/exceptions.py
app/core/utils/utils.py
app/manage.py
app/serializers/company.py
app/serializers/members.py
app/serializers/offers.py
invoice.py
projects/getDiff.sh
pyproject.toml
requirements/base.txt
terraform/app.tf
terraform/connectors.tf
terraform/databases.tf
terraform/main.tf
terraform/modules/app/main.tf
terraform/modules/app/outputs.tf
terraform/modules/app/variables.tf
terraform/modules/connectors/main.tf
terraform/modules/connectors/outputs.tf
terraform/modules/connectors/variables.tf
terraform/outputs.tf
terraform/variables.tf

Diff:
```diff
diff --git a/.devcontainer/devcontainer.json b/.devcontainer/devcontainer.json
index 2715788..efc8f6b 100644
--- a/.devcontainer/devcontainer.json
+++ b/.devcontainer/devcontainer.json
@@ -16,7 +16,8 @@
                 "njpwerner.autodocstring",
                 "streetsidesoftware.code-spell-checker",
                 "eamodio.gitlens",
-                "visualstudioexptteam.vscodeintellicode"
+                "visualstudioexptteam.vscodeintellicode",
+                "saoudrizwan.claude-dev"
             ],
             "settings": {
                 "python.defaultInterpreterPath": "/usr/local/bin/python",
diff --git a/.env.example b/.env.example
index a1fe0e3..a11f308 100644
--- a/.env.example
+++ b/.env.example
@@ -1,20 +1,14 @@
-# Server Configuration
-# These are set by default to the values below in dev environments
-# Uncomment and use live values on demo and prod deployments
-#REDIS_URL=redis://localhost:6379
-#CELERY_BROKER_REDIS_URL=localhost:6380
-
+DEBUG=True
 DJANGO_SECRET=your_random_string
 
 # Credex Core API Configuration
-MYCREDEX_APP_URL=https://dev.mycredex.dev/  # Base URL for credex-core API (v1 is added automatically)
+MYCREDEX_APP_URL=https://dev.mycredex.dev/
+CLIENT_API_KEY=random_string_same_value_as_credex-core
 
 # WhatsApp Integration
-WHATSAPP_BOT_API_KEY=your_random_string_same_value_as_credex-core
 WHATSAPP_API_URL=https://graph.facebook.com/v17.0/  # WhatsApp Graph API URL
-WHATSAPP_ACCESS_TOKEN=your_whatsapp_access_token
-WHATSAPP_PHONE_NUMBER_ID=your_whatsapp_phone_number_id
-
-# Optional Development Settings
-#X_GITHUB_TOKEN=your_github_token  # Only used in dev environment
-#ENV=dev  # Defaults to 'dev' if not set
+WHATSAPP_ACCESS_TOKEN=your_variable_assigned_by_whatsapp
+WHATSAPP_PHONE_NUMBER_ID=your_variable_assigned_by_whatsapp
+WHATSAPP_BUSINESS_ID=your_variable_assigned_by_whatsapp
+WHATSAPP_REGISTRATION_FLOW_ID=your_variable_assigned_by_whatsapp
+WHATSAPP_COMPANY_REGISTRATION_FLOW_ID=your_variable_assigned_by_whatsapp
\ No newline at end of file
diff --git a/.flake8 b/.flake8
new file mode 100644
index 0000000..c31609a
--- /dev/null
+++ b/.flake8
@@ -0,0 +1,7 @@
+[flake8]
+max-line-length = 88
+extend-ignore = E203, W503
+exclude = .git,__pycache__,build,dist
+per-file-ignores =
+    # imported but unused
+    __init__.py: F401
diff --git a/.github/workflows/app.yml b/.github/workflows/app.yml
index 58be0dd..3b90671 100644
--- a/.github/workflows/app.yml
+++ b/.github/workflows/app.yml
@@ -66,7 +66,7 @@ jobs:
           TF_VAR_docker_image: ${{ env.IMAGE }}
           TF_VAR_django_secret: ${{ secrets.DJANGO_SECRET }}
           TF_VAR_mycredex_app_url: ${{ secrets.MYCREDEX_APP_URL }}
-          TF_VAR_whatsapp_bot_api_key: ${{ secrets.WHATSAPP_BOT_API_KEY }}
+          TF_VAR_client_api_key: ${{ secrets.CLIENT_API_KEY }}
           TF_VAR_whatsapp_api_url: ${{ secrets.WHATSAPP_API_URL }}
           TF_VAR_whatsapp_access_token: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
           TF_VAR_whatsapp_phone_number_id: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
@@ -82,7 +82,7 @@ jobs:
           TF_VAR_docker_image: ${{ env.IMAGE }}
           TF_VAR_django_secret: ${{ secrets.DJANGO_SECRET }}
           TF_VAR_mycredex_app_url: ${{ secrets.MYCREDEX_APP_URL }}
-          TF_VAR_whatsapp_bot_api_key: ${{ secrets.WHATSAPP_BOT_API_KEY }}
+          TF_VAR_client_api_key: ${{ secrets.CLIENT_API_KEY }}
           TF_VAR_whatsapp_api_url: ${{ secrets.WHATSAPP_API_URL }}
           TF_VAR_whatsapp_access_token: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
           TF_VAR_whatsapp_phone_number_id: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
diff --git a/.github/workflows/connectors.yml b/.github/workflows/connectors.yml
index 06e00ab..50b8285 100644
--- a/.github/workflows/connectors.yml
+++ b/.github/workflows/connectors.yml
@@ -71,7 +71,7 @@ jobs:
           # Add dummy values for required application variables
           TF_VAR_django_secret: "dummy"
           TF_VAR_mycredex_app_url: "dummy"
-          TF_VAR_whatsapp_bot_api_key: "dummy"
+          TF_VAR_client_api_key: "dummy"
           TF_VAR_whatsapp_api_url: "dummy"
           TF_VAR_whatsapp_access_token: "dummy"
           TF_VAR_whatsapp_phone_number_id: "dummy"
@@ -89,7 +89,7 @@ jobs:
           # Add dummy values for required application variables
           TF_VAR_django_secret: "dummy"
           TF_VAR_mycredex_app_url: "dummy"
-          TF_VAR_whatsapp_bot_api_key: "dummy"
+          TF_VAR_client_api_key: "dummy"
           TF_VAR_whatsapp_api_url: "dummy"
           TF_VAR_whatsapp_access_token: "dummy"
           TF_VAR_whatsapp_phone_number_id: "dummy"
diff --git a/DEPLOYMENT.md b/DEPLOYMENT.md
deleted file mode 100644
index 73e40b0..0000000
--- a/DEPLOYMENT.md
+++ /dev/null
@@ -1,246 +0,0 @@
-# Vimbiso Pay Deployment Guide
-
-This document outlines the deployment process and infrastructure for the Vimbiso Pay application.
-
-## Infrastructure Overview
-
-The application is deployed on AWS using:
-- ECS Fargate for container orchestration
-- Application Load Balancer for routing and SSL termination
-- ECR for container registry
-- CloudWatch for logging and monitoring
-- S3 and DynamoDB for Terraform state management
-
-### Environments
-
-Two deployment environments are supported:
-1. Staging (stage.mycredex.dev)
-   - Moderate resource allocation
-   - Used for pre-production testing
-   - Connects to staging Credex Core API
-
-2. Production (mycredex.app)
-   - Higher resource allocation
-   - Production-grade configuration
-   - Connects to production Credex Core API
-
-## Prerequisites
-
-1. AWS Access:
-   - AWS access key and secret with appropriate permissions
-   - Access to the af-south-1 region
-
-2. GitHub Repository Access:
-   - Write access to the repository
-   - Ability to manage GitHub Actions secrets
-
-3. Required Secrets:
-   ```
-   # AWS Configuration
-   AWS_ACCESS_KEY
-   AWS_SECRET_ACCESS_KEY
-
-   # Django Configuration
-   DJANGO_SECRET
-
-   # Credex Core API
-   MYCREDEX_APP_URL
-
-   # WhatsApp Integration
-   WHATSAPP_BOT_API_KEY
-   WHATSAPP_API_URL
-   WHATSAPP_ACCESS_TOKEN
-   WHATSAPP_PHONE_NUMBER_ID
-   ```
-
-## Deployment Process
-
-### 1. Infrastructure Deployment
-
-The infrastructure is deployed using the `connectors.yml` workflow:
-
-1. Navigate to Actions → Deploy Infrastructure
-2. Select the branch:
-   - `stage` for staging environment
-   - `prod` for production environment
-3. Run workflow
-
-This deploys:
-- VPC and networking
-- Load balancer and target groups
-- Security groups
-- IAM roles
-- ECR repository
-
-### 2. Application Deployment
-
-The application is deployed using the `app.yml` workflow:
-
-1. Navigate to Actions → Deploy Application
-2. Select the branch:
-   - `stage` for staging environment
-   - `prod` for production environment
-3. Run workflow
-
-This performs:
-- Docker image build
-- ECR push
-- ECS service update
-- Deployment monitoring
-
-## Infrastructure Details
-
-### Networking
-
-- VPC with public and private subnets
-- NAT gateways for private subnet internet access
-- Application Load Balancer in public subnets
-- ECS tasks in private subnets
-
-### Container Configuration
-
-- Port 8000 exposed for Django application
-- Health check at /health/
-- Environment variables injected via ECS task definition
-
-### Auto Scaling
-
-Staging:
-```json
-{
-  "min_capacity": 2,
-  "max_capacity": 4,
-  "cpu_threshold": 80,
-  "memory_threshold": 80
-}
-```
-
-Production:
-```json
-{
-  "min_capacity": 2,
-  "max_capacity": 6,
-  "cpu_threshold": 75,
-  "memory_threshold": 75
-}
-```
-
-## Monitoring and Logs
-
-1. CloudWatch Logs:
-   - Log group: /ecs/vimbiso-pay-{environment}
-   - Contains application and ECS logs
-
-2. Health Checks:
-   - ALB health check at /health/
-   - Container health check via curl
-   - ECS service health monitoring
-
-3. Metrics:
-   - CPU and memory utilization
-   - Request count and latency
-   - 5xx error rate
-
-## Troubleshooting
-
-### Common Issues
-
-1. Deployment Failures:
-   - Check ECS task logs in CloudWatch
-   - Verify environment variables
-   - Check container health check
-   - Verify security group rules
-
-2. Health Check Failures:
-   - Verify /health/ endpoint is responding
-   - Check ALB target group settings
-   - Review security group rules
-
-3. Auto Scaling Issues:
-   - Review CloudWatch metrics
-   - Check scaling policy thresholds
-   - Verify ECS service configuration
-
-### Rollback Process
-
-1. Infrastructure:
-   ```bash
-   # Revert to previous state
-   terraform plan -target=module.connectors -out=tfplan
-   terraform apply tfplan
-   ```
-
-2. Application:
-   ```bash
-   # Revert to previous image
-   aws ecs update-service --cluster vimbiso-pay-cluster-{env} \
-     --service vimbiso-pay-service-{env} \
-     --task-definition {previous-task-def}
-   ```
-
-## Security Considerations
-
-1. Network Security:
-   - Private subnets for ECS tasks
-   - Security groups limit access
-   - SSL/TLS termination at ALB
-
-2. Authentication:
-   - WhatsApp API tokens in ECS secrets
-   - Django secret managed via ECS
-   - AWS IAM roles for service access
-
-3. Monitoring:
-   - CloudWatch alarms for errors
-   - Access logging enabled
-   - Security group changes tracked
-
-## Maintenance
-
-### Regular Tasks
-
-1. ECR Cleanup:
-   ```bash
-   # Remove untagged images
-   aws ecr list-images --repository-name vimbiso-pay-{env} \
-     --filter tagStatus=UNTAGGED \
-     --query 'imageIds[*]' --output json > untagged.json
-   aws ecr batch-delete-image --repository-name vimbiso-pay-{env} \
-     --image-ids file://untagged.json
-   ```
-
-2. Log Retention:
-   - CloudWatch logs retained for 30 days
-   - Consider archiving important logs
-
-3. SSL Certificate:
-   - Auto-renewed via ACM
-   - Monitor renewal status
-
-### Backup Strategy
-
-1. Infrastructure State:
-   - S3 bucket versioning enabled
-   - DynamoDB point-in-time recovery
-   - Regular state backups recommended
-
-2. Application Data:
-   - SQLite database backed up with ECS task
-   - Consider implementing automated backups
-
-## Future Improvements
-
-1. Monitoring:
-   - Add custom CloudWatch dashboards
-   - Implement better error tracking
-   - Set up automated alerts
-
-2. Performance:
-   - Implement caching strategy
-   - Optimize container configuration
-   - Fine-tune auto-scaling
-
-3. Security:
-   - Implement WAF rules
-   - Add rate limiting
-   - Enhance logging and auditing
diff --git a/Dockerfile b/Dockerfile
index 444e61e..c045bfb 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -14,6 +14,7 @@ ENV PYTHONDONTWRITEBYTECODE=1 \
 RUN apt-get update && apt-get install -y \
     curl \
     locales \
+    libpq-dev \
     && locale-gen en_US.UTF-8 \
     && update-locale \
     && rm -rf /var/lib/apt/lists/*
diff --git a/LICENSE b/LICENSE
deleted file mode 100644
index 261eeb9..0000000
--- a/LICENSE
+++ /dev/null
@@ -1,201 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/README.Docker.md b/README.Docker.md
deleted file mode 100644
index 6dae561..0000000
--- a/README.Docker.md
+++ /dev/null
@@ -1,22 +0,0 @@
-### Building and running your application
-
-When you're ready, start your application by running:
-`docker compose up --build`.
-
-Your application will be available at http://localhost:8000.
-
-### Deploying your application to the cloud
-
-First, build your image, e.g.: `docker build -t myapp .`.
-If your cloud uses a different CPU architecture than your development
-machine (e.g., you are on a Mac M1 and your cloud provider is amd64),
-you'll want to build the image for that platform, e.g.:
-`docker build --platform=linux/amd64 -t myapp .`.
-
-Then, push it to your registry, e.g. `docker push myregistry.com/myapp`.
-
-Consult Docker's [getting started](https://docs.docker.com/go/get-started-sharing/)
-docs for more detail on building and pushing.
-
-### References
-* [Docker's Python guide](https://docs.docker.com/language/python/)
\ No newline at end of file
diff --git a/README.md b/README.md
index f909ec0..fa9b7fd 100644
--- a/README.md
+++ b/README.md
@@ -1,204 +1,174 @@
 # VimbisoPay
 
-A WhatsApp-based client application that interacts with the Credex Core API.
+A WhatsApp bot service that facilitates financial transactions through the credex-core API, enabling users to manage their credex accounts and perform financial operations directly in a secure WhatsApp chat.
 
-## Local Development Setup
-
-### Prerequisites
-- Docker and Docker Compose
-- VSCode with Remote Containers extension (for devcontainer usage)
-- Access to dev.mycredex.dev API
-- WhatsApp API credentials
-
-### Environment Setup
-
-1. Clone the repository
-2. Copy `.env.example` to `.env` and fill in the required values:
+### Quick Start
+After cloning and seting up environment variables, or activation of a codespace, start development environment with:
 ```bash
-   cp .env.example .env
+docker compose -f app/compose.yaml up --build
 ```
 
-   Required environment variables:
-   - `DJANGO_SECRET`: Django secret key
-   - `MYCREDEX_APP_URL`: Set to `https://dev.mycredex.dev/` for development
-   - `WHATSAPP_BOT_API_KEY`: Must match the value used in credex-core
-   - `WHATSAPP_API_URL`: WhatsApp Graph API URL
-   - `WHATSAPP_ACCESS_TOKEN`: Your WhatsApp API access token
-   - `WHATSAPP_PHONE_NUMBER_ID`: Your WhatsApp phone number ID
-
-### Development with VSCode Devcontainer
+The application will be available at http://localhost:8000
+
+## Core Features
+
+### Financial Operations
+- Secured credex transactions with immediate settlement
+- Unsecured credex with configurable due dates (up to 5 weeks)
+- Multi-tier account system:
+  - Personal accounts with basic features
+  - Business accounts with advanced capabilities
+  - Member authorization management
+- Balance tracking with denomination support
+- Transaction history with pagination
+- Pending offers management:
+  - Individual and bulk acceptance
+  - Offer cancellation
+  - Review of incoming/outgoing offers
+
+### Transaction Commands
+- Quick transaction shortcuts:
+  - `0.5=>handle` for secured CredEx
+  - `0.5->handle` for unsecured CredEx
+  - `0.5->handle=2024-02-01` for dated unsecured CredEx
+- Menu-based transaction creation
+- Bulk transaction handling
+- Transaction validation and confirmation
+
+### WhatsApp Interface
+- Interactive menus and buttons
+- Form-based data collection with validation
+- Rich message formatting with emojis
+- State-based conversation flow with Redis persistence:
+  - 5-minute session timeout
+  - Automatic state cleanup
+  - Cross-device state sync
+- Time-aware greetings and messages
+- Navigation commands:
+  - `menu` - Return to main menu
+  - `x` or `c` - Cancel current operation
+  - `home` - Return to account dashboard
+- Custom message templates for:
+  - Account balances and limits
+  - Transaction history
+  - Offer confirmations
+  - Error messages
+  - Status updates
+- Notification preferences per account
+
+### Security
+- JWT authentication with configurable lifetimes
+- Rate limiting (100/day anonymous, 1000/day authenticated)
+- XSS protection and HSTS
+- CORS configuration
+- Input validation and sanitization
+- Secure state management
+
+## Development Setup
 
-1. Open the project in VSCode
-2. When prompted, click "Reopen in Container" or run the command palette (F1) and select "Remote-Containers: Reopen in Container"
-3. VSCode will build and start the development container with all required extensions and dependencies
-
-### Manual Development Setup
-
-If not using devcontainer:
+### Prerequisites
+- Docker and Docker Compose
+- Python 3.10+
+- Access to Credex Core API
+- WhatsApp Business API credentials
 
-1. Build and start the services:
+### Quick Start
+After cloning and seting up environment variables, or activation of a codespace, start development environment with:
 ```bash
 docker compose -f app/compose.yaml up --build
 ```
 
-2. The application will be available at http://localhost:8000
-
-### Verifying Development Setup
+The application will be available at http://localhost:8000
 
-The application provides test endpoints to verify all integrations are working correctly:
+### Development Features
+- Live code reloading
+- Django Debug Toolbar
+- SQLite database
+- Redis for state management
+- Console email backend
+- Comprehensive logging
 
-1. Basic Health Check:
+### Code Quality
 ```bash
-   curl http://localhost:8000/health/
-   ```
-   Should return "OK"
-
-2. Integration Tests:
-   ```bash
-   curl http://localhost:8000/api/test-integrations/
-   ```
-   This endpoint tests:
-   - Django setup
-   - Redis connection
-   - Credex Core API connectivity
-   - WhatsApp API configuration
-
-   The response will include the status of each component:
-   ```json
-   {
-     "status": "success",
-     "tests": {
-       "django": { "status": "success", "message": "..." },
-       "redis": { "status": "success", "message": "..." },
-       "credex_api": { "status": "success", "message": "..." },
-       "whatsapp": { "status": "success", "message": "..." }
-     }
-   }
-   ```
-
-### Development Workflow
-
-- The application runs in development mode with live reload enabled
-- Code changes will automatically reload the development server
-- Redis is available at localhost:6379
-- API requests will be forwarded to dev.mycredex.dev
-- WhatsApp messages can be tested using the configured WhatsApp number
-
-### Health Checks
-
-- Application health check: http://localhost:8000/health/
-- Redis health is monitored automatically
-- Integration status: http://localhost:8000/api/test-integrations/
-
-### Deployment
-
-For deployment instructions, see [README.Docker.md](README.Docker.md)
-
-## GitHub Codespaces Development
-
-### Codespaces Setup
+# Format and lint
+black .
+isort .
+flake8
 
-1. Open the repository in GitHub Codespaces
-2. The devcontainer configuration will automatically set up your development environment
+# Type checking
+mypy .
 
-### Environment Configuration for Codespaces
-
-When working in Codespaces, you need to set up environment variables:
-
-1. Create a `.env` file from template:
-   ```bash
-   cp .env.example .env
+# Run tests
+pytest --cov=app
 ```
 
-2. Required Codespaces-specific configuration:
-   - `X_GITHUB_TOKEN`: Required for API access from Codespaces
-     - Generate a Personal Access Token in GitHub with appropriate scopes
-     - This token is needed for authentication when making requests to dev.mycredex.dev
-     - Without this token, API requests from Codespaces will be blocked
-
-3. Set Codespaces Secrets:
-   - Go to GitHub Repository Settings
-   - Navigate to Secrets and Variables > Codespaces
-   - Add the following secrets:
-     - `X_GITHUB_TOKEN`
-     - Other environment variables from `.env.example`
-
-### Testing in Codespaces
-
-When testing API endpoints in Codespaces, ensure:
+## Production Deployment
 
-1. The `X_GITHUB_TOKEN` is properly set in your environment
-2. Include the token in API requests:
-   ```bash
-   # Using curl
-   curl -H "X-Github-Token: $X_GITHUB_TOKEN" http://localhost:8000/api/test-integrations/
-   
-   # Using the test endpoint
-   # The test endpoint automatically includes the token if ENV=dev
-   ```
+### Docker Configuration
+- Multi-stage builds
+- Security-hardened production image
+- Non-privileged user
+- Gunicorn with gevent workers
+- Health monitoring
 
-### Codespaces Development Workflow
-
-1. Start the application:
+### Server Configuration
 ```bash
-   docker compose -f app/compose.yaml up --build
+# Build production image
+docker build --target production -t vimbiso-pay:latest .
+
+# Run with production settings
+docker run -d \
+  --name vimbiso-pay \
+  -p 8000:8000 \
+  -e DJANGO_ENV=production \
+  [additional environment variables]
+  vimbiso-pay:latest
 ```
 
-2. Access the application through the Codespaces forwarded ports
-   - Codespaces automatically forwards port 8000
-   - Use the Codespaces URL provided in the ports tab
-
-3. For API testing:
-   - Always include `X-Github-Token` header in requests
-   - Use the test endpoints to verify connectivity
-   - Monitor the Django debug toolbar for request details
-
-## Architecture
-
-### Components
-- Django application with WhatsApp integration
-- Redis for caching and message handling
-- Connection to Credex Core API
-
-### Environment Structure
-- Development: Local development with dev.mycredex.dev API
-- Staging: (configured in terraform)
-- Production: (configured in terraform)
-
-## Contributing
-
-1. Create a feature branch
-2. Make your changes
-3. Submit a pull request
+### Health Monitoring
+- Built-in health checks (30s interval)
+- Redis connection monitoring
+- API integration verification
+- Comprehensive logging
 
 ## Troubleshooting
 
 ### Common Issues
-
-1. API Connection Issues
-   - Verify MYCREDEX_APP_URL is set correctly
-   - Check if dev.mycredex.dev is accessible
-   - In Codespaces: Verify X_GITHUB_TOKEN is set and valid
-   - Use /api/test-integrations/ to verify connectivity
+1. API Connection
+   - Verify API URL and credentials
+   - Check network connectivity
+   - Validate JWT token
 
 2. WhatsApp Integration
-   - Ensure all WhatsApp environment variables are set
-   - Verify WHATSAPP_BOT_API_KEY matches credex-core
-   - Check WhatsApp configuration via /api/test-integrations/
+   - Verify API credentials
+   - Test webhook configuration
+   - Check message templates
 
-3. Redis Connection
-   - Check if Redis container is running
-   - Verify REDIS_URL in environment
-   - Use /api/test-integrations/ to test Redis connection
-
-4. Codespaces-Specific Issues
-   - Missing X_GITHUB_TOKEN: API requests will fail
-   - Port forwarding: Check Ports tab in Codespaces
-   - Environment variables: Verify they're set in Codespaces secrets
+3. State Management
+   - Verify Redis connection
+   - Check session timeouts (5 minutes)
+   - Monitor state transitions
 
 ### Debug Mode
-
-The application runs in debug mode during development, providing:
 - Django Debug Toolbar at /__debug__/
 - Detailed error pages
 - Auto-reload on code changes
+- Console email backend
+- Comprehensive logging
+
+## Future Improvements
+
+1. Monitoring
+   - JSON logging configuration
+   - Error tracking
+   - Performance metrics
+
+2. Performance
+   - Redis caching strategy
+   - Container optimization
+   - State management tuning
+
+3. Infrastructure
+   - AWS deployment
+   - Terraform configurations
+   - Production deployment guide
diff --git a/app/compose.yaml b/app/compose.yaml
index d574c88..664abcb 100644
--- a/app/compose.yaml
+++ b/app/compose.yaml
@@ -12,11 +12,17 @@ services:
       - DJANGO_SECRET=${DJANGO_SECRET}
       - DEBUG=1
       - REDIS_URL=redis://redis:6379/
+      # Database settings
+      - DEFAULT_DATABASE=credex
+      - DATABASE_USER=credex
+      - DATABASE_PASSWORD=CredexUser#
+      - DATABASE_HOST=db
+      - DATABASE_PORT=5432
       # WhatsApp Integration
       - WHATSAPP_API_URL=${WHATSAPP_API_URL}
       - WHATSAPP_ACCESS_TOKEN=${WHATSAPP_ACCESS_TOKEN}
       - WHATSAPP_PHONE_NUMBER_ID=${WHATSAPP_PHONE_NUMBER_ID}
-      - WHATSAPP_BOT_API_KEY=${WHATSAPP_BOT_API_KEY}
+      - CLIENT_API_KEY=${CLIENT_API_KEY}
       # Credex Core API
       - MYCREDEX_APP_URL=${MYCREDEX_APP_URL}
       # Development Settings
@@ -32,6 +38,8 @@ services:
     depends_on:
       redis:
         condition: service_healthy
+      db:
+        condition: service_healthy
     command: >
       sh -c "python manage.py migrate &&
              python manage.py runserver 0.0.0.0:8000"
@@ -54,6 +62,23 @@ services:
         - action: rebuild
           path: requirements/dev.txt
 
+  db:
+    image: postgres:15-alpine
+    environment:
+      - POSTGRES_DB=credex
+      - POSTGRES_USER=credex
+      - POSTGRES_PASSWORD=CredexUser#
+    volumes:
+      - postgres_data:/var/lib/postgresql/data
+    ports:
+      - "5432:5432"
+    healthcheck:
+      test: ["CMD-SHELL", "pg_isready -U credex"]
+      interval: 10s
+      timeout: 5s
+      retries: 5
+      start_period: 10s
+
   redis:
     image: redis:7-alpine
     ports:
@@ -71,3 +96,4 @@ services:
 volumes:
   redis_data:
   python-packages:
+  postgres_data:
diff --git a/app/config/asgi.py b/app/config/asgi.py
index a00b3b5..856079b 100644
--- a/app/config/asgi.py
+++ b/app/config/asgi.py
@@ -2,6 +2,6 @@ import os
 
 from django.core.asgi import get_asgi_application
 
-os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
 
 application = get_asgi_application()
diff --git a/app/config/settings.py b/app/config/settings.py
index bf12a06..e8f4274 100644
--- a/app/config/settings.py
+++ b/app/config/settings.py
@@ -1,201 +1,208 @@
+from corsheaders.defaults import default_headers
 from decouple import config as env
 from pathlib import Path
-import os
 from datetime import timedelta
 
-
 # Build paths inside the project like this: BASE_DIR / 'subdir'.
 BASE_DIR = Path(__file__).resolve().parent.parent
 
 # SECURITY WARNING: keep the secret key used in production secret!
-SECRET_KEY = env('DJANGO_SECRET')
+SECRET_KEY = env("DJANGO_SECRET")
 
 # SECURITY WARNING: don't run with debug turned on in production!
-DEBUG = True
+DEBUG = env('DEBUG', default=False, cast=bool)
 
-ALLOWED_HOSTS = ['*']  # ['localhost', '127.0.0.1']
+ALLOWED_HOSTS = ["*"]  # ['localhost', '127.0.0.1']
 
 # Application definition
 INSTALLED_APPS = [
-    'django.contrib.admin',
-    'django.contrib.auth',
-    'django.contrib.contenttypes',
-    'django.contrib.sessions',
-    'django.contrib.messages',
-    'django.contrib.staticfiles',
-
+    "django.contrib.admin",
+    "django.contrib.auth",
+    "django.contrib.contenttypes",
+    "django.contrib.sessions",
+    "django.contrib.messages",
+    "django.contrib.staticfiles",
     # Custom apps
-    'rest_framework',
-    'rest_framework_simplejwt',
-    'core.config.apps.CoreConfig',
-    'debug_toolbar',  # Added for development
+    "rest_framework",
+    "rest_framework_simplejwt",
+    "core.config.apps.CoreConfig",
+    "debug_toolbar",  # Added for development
 ]
 
 MIDDLEWARE = [
-    'django.middleware.security.SecurityMiddleware',
-    'django.contrib.sessions.middleware.SessionMiddleware',
-    'django.middleware.common.CommonMiddleware',
+    "django.middleware.security.SecurityMiddleware",
+    "django.contrib.sessions.middleware.SessionMiddleware",
+    "django.middleware.common.CommonMiddleware",
     "corsheaders.middleware.CorsMiddleware",
-    'django.middleware.csrf.CsrfViewMiddleware',
-    'django.contrib.auth.middleware.AuthenticationMiddleware',
-    'django.contrib.messages.middleware.MessageMiddleware',
-    'django.middleware.clickjacking.XFrameOptionsMiddleware',
-    'django.middleware.security.SecurityMiddleware',
-    'debug_toolbar.middleware.DebugToolbarMiddleware',  # Added for development
+    "django.middleware.csrf.CsrfViewMiddleware",
+    "django.contrib.auth.middleware.AuthenticationMiddleware",
+    "django.contrib.messages.middleware.MessageMiddleware",
+    "django.middleware.clickjacking.XFrameOptionsMiddleware",
+    "django.middleware.security.SecurityMiddleware",
+    "debug_toolbar.middleware.DebugToolbarMiddleware",  # Added for development
 ]
 
-ROOT_URLCONF = 'config.urls'
+ROOT_URLCONF = "config.urls"
 
 TEMPLATES = [
     {
-        'BACKEND': 'django.template.backends.django.DjangoTemplates',
-        'DIRS': [],
-        'APP_DIRS': True,
-        'OPTIONS': {
-            'context_processors': [
-                'django.template.context_processors.debug',
-                'django.template.context_processors.request',
-                'django.contrib.auth.context_processors.auth',
-                'django.contrib.messages.context_processors.messages',
+        "BACKEND": "django.template.backends.django.DjangoTemplates",
+        "DIRS": [],
+        "APP_DIRS": True,
+        "OPTIONS": {
+            "context_processors": [
+                "django.template.context_processors.debug",
+                "django.template.context_processors.request",
+                "django.contrib.auth.context_processors.auth",
+                "django.contrib.messages.context_processors.messages",
             ],
         },
     },
 ]
 
-WSGI_APPLICATION = 'config.wsgi.application'
+WSGI_APPLICATION = "config.wsgi.application"
 
 # Database
 DATABASES = {
     'default': {
-        'ENGINE': 'django.db.backends.sqlite3',
-        'NAME': BASE_DIR / 'db.sqlite3',
+        'ENGINE': 'django.db.backends.postgresql',
+        'NAME': env('DEFAULT_DATABASE', default='credex'),
+        'USER': env('DATABASE_USER', default='credex'),
+        'PASSWORD': env('DATABASE_PASSWORD', default='CredexUser#'),
+        'HOST': env('DATABASE_HOST', default='localhost'),
+        'PORT': env('DATABASE_PORT', default=5432, cast=int),
     }
 }
 
 # Password validation
 AUTH_PASSWORD_VALIDATORS = [
     {
-        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
+        'NAME': (
+            'django.contrib.auth.password_validation.'
+            'UserAttributeSimilarityValidator'
+        ),
     },
     {
-        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
+        'NAME': (
+            'django.contrib.auth.password_validation.'
+            'MinimumLengthValidator'
+        ),
     },
     {
-        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
+        'NAME': (
+            'django.contrib.auth.password_validation.'
+            'CommonPasswordValidator'
+        ),
     },
     {
-        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
+        'NAME': (
+            'django.contrib.auth.password_validation.'
+            'NumericPasswordValidator'
+        ),
     },
 ]
 
 # Internationalization
-LANGUAGE_CODE = 'en-us'
-TIME_ZONE = 'Africa/Harare'
+LANGUAGE_CODE = "en-us"
+TIME_ZONE = "Africa/Harare"
 USE_I18N = True
 USE_TZ = True
 
 # Static files (CSS, JavaScript, Images)
-STATIC_URL = '/static/'
-STATIC_ROOT = Path.joinpath(BASE_DIR, 'static')
+STATIC_URL = "/static/"
+STATIC_ROOT = Path.joinpath(BASE_DIR, "static")
 
 MEDIA_ROOT = Path.joinpath(BASE_DIR, "media")
-MEDIA_URL = '/media/'
+MEDIA_URL = "/media/"
 
 # Default primary key field type
-DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
+DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
 
 REST_FRAMEWORK = {
     'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema',
-    'DEFAULT_PERMISSION_CLASSES': ['rest_framework.permissions.IsAuthenticated'],
+    'DEFAULT_PERMISSION_CLASSES': [
+        'rest_framework.permissions.IsAuthenticated'
+    ],
     'DEFAULT_PARSER_CLASSES': [
         'rest_framework.parsers.JSONParser',
         'rest_framework.parsers.FormParser',
         'rest_framework.parsers.MultiPartParser',
         'rest_framework_xml.parsers.XMLParser',
     ],
-    'DEFAULT_RENDERER_CLASSES': [
-        'rest_framework.renderers.JSONRenderer',
-        'rest_framework.renderers.BrowsableAPIRenderer',
-        'rest_framework_xml.renderers.XMLRenderer',
+    "DEFAULT_RENDERER_CLASSES": [
+        "rest_framework.renderers.JSONRenderer",
+        "rest_framework.renderers.BrowsableAPIRenderer",
+        "rest_framework_xml.renderers.XMLRenderer",
     ],
     "DEFAULT_AUTHENTICATION_CLASSES": [
         "rest_framework_simplejwt.authentication.JWTAuthentication",
     ],
-    'DEFAULT_THROTTLE_CLASSES': [
-        'rest_framework.throttling.AnonRateThrottle',
-        'rest_framework.throttling.UserRateThrottle'
+    "DEFAULT_THROTTLE_CLASSES": [
+        "rest_framework.throttling.AnonRateThrottle",
+        "rest_framework.throttling.UserRateThrottle",
     ],
-    'DEFAULT_THROTTLE_RATES': {
-        'anon': '100/day',
-        'user': '1000/day'
-    }
+    "DEFAULT_THROTTLE_RATES": {"anon": "100/day", "user": "1000/day"},
 }
 
 # JWT settings
 SIMPLE_JWT = {
-    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
-    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
-    'ROTATE_REFRESH_TOKENS': False,
-    'BLACKLIST_AFTER_ROTATION': True,
-    'UPDATE_LAST_LOGIN': False,
-
-    'ALGORITHM': 'HS256',
-    'SIGNING_KEY': SECRET_KEY,
-    'VERIFYING_KEY': None,
-    'AUDIENCE': None,
-    'ISSUER': None,
-
-    'AUTH_HEADER_TYPES': ('Bearer',),
-    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',
-    'USER_ID_FIELD': 'id',
-    'USER_ID_CLAIM': 'user_id',
-
-    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
-    'TOKEN_TYPE_CLAIM': 'token_type',
-
-    'JTI_CLAIM': 'jti',
-
-    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',
-    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),
-    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),
+    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=60),
+    "REFRESH_TOKEN_LIFETIME": timedelta(days=1),
+    "ROTATE_REFRESH_TOKENS": False,
+    "BLACKLIST_AFTER_ROTATION": True,
+    "UPDATE_LAST_LOGIN": False,
+    "ALGORITHM": "HS256",
+    "SIGNING_KEY": SECRET_KEY,
+    "VERIFYING_KEY": None,
+    "AUDIENCE": None,
+    "ISSUER": None,
+    "AUTH_HEADER_TYPES": ("Bearer",),
+    "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",
+    "USER_ID_FIELD": "id",
+    "USER_ID_CLAIM": "user_id",
+    "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
+    "TOKEN_TYPE_CLAIM": "token_type",
+    "JTI_CLAIM": "jti",
+    "SLIDING_TOKEN_REFRESH_EXP_CLAIM": "refresh_exp",
+    "SLIDING_TOKEN_LIFETIME": timedelta(minutes=5),
+    "SLIDING_TOKEN_REFRESH_LIFETIME": timedelta(days=1),
 }
 
-from corsheaders.defaults import default_headers
-
-CORS_ALLOW_HEADERS = list(default_headers) + [
-    'apiKey'
-]
+CORS_ALLOW_HEADERS = list(default_headers) + ["apiKey"]
 
 # Debug toolbar settings
 INTERNAL_IPS = [
-    '127.0.0.1',
+    "127.0.0.1",
 ]
 
-# Disable some production-only security settings in development
-CSRF_COOKIE_SECURE = False
-SESSION_COOKIE_SECURE = False
-SECURE_SSL_REDIRECT = False
+# Security settings based on environment
+CSRF_COOKIE_SECURE = not DEBUG
+SESSION_COOKIE_SECURE = not DEBUG
+SECURE_SSL_REDIRECT = not DEBUG
 
-# Email backend for development (prints emails to console)
+# Email backend configuration
+if DEBUG:
     EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
+else:
+    EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
 
 # Cache
 CACHES = {
-    'default': {
-        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
+    "default": {
+        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
     }
 }
 
 # Security Settings
 SECURE_BROWSER_XSS_FILTER = True
 SECURE_CONTENT_TYPE_NOSNIFF = True
-X_FRAME_OPTIONS = 'DENY'
+X_FRAME_OPTIONS = "DENY"
 SECURE_HSTS_SECONDS = 31536000  # 1 year
 SECURE_HSTS_INCLUDE_SUBDOMAINS = True
 SECURE_HSTS_PRELOAD = True
 
 # Logging configuration (commented out for now, can be uncommented if needed)
-'''
+"""
 LOGGING = {
     'version': 1,
     'disable_existing_loggers': False,
@@ -205,7 +212,10 @@ LOGGING = {
             'format': '%(asctime)s %(levelname)s %(name)s %(message)s',
         },
         'verbose': {
-            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
+            'format': (
+                '{levelname} {asctime} {module} {process:d} '
+                '{thread:d} {message}'
+            ),
             'style': '{',
         },
     },
@@ -217,7 +227,10 @@ LOGGING = {
         },
         'file': {
             'class': 'logging.handlers.RotatingFileHandler',
-            'filename': env('LOG_FILE', default=os.path.join(BASE_DIR, 'logs/application.log')),
+            'filename': env(
+                'LOG_FILE',
+                default=str(BASE_DIR / 'logs/application.log')
+            ),
             'maxBytes': 1024 * 1024 * 5,  # 5 MB
             'backupCount': 5,
             'formatter': 'json',
@@ -245,5 +258,4 @@ LOGGING = {
         'level': 'DEBUG',
     },
 }
-'''
-
+"""
diff --git a/app/config/urls.py b/app/config/urls.py
index 5fb31a2..d84f67b 100644
--- a/app/config/urls.py
+++ b/app/config/urls.py
@@ -7,7 +7,7 @@ from core.api.views import (
     CredexCloudApiWebhook,
     CredexSendMessageWebhook,
     WelcomeMessage,
-    WipeCache
+    WipeCache,
 )
 from core.api.tests import test_integrations
 
@@ -15,23 +16,23 @@ from core.api.tests import test_integrations
 def health_check(request):
     return HttpResponse("OK")
 
-urlpatterns = [
-    path('admin/', admin.site.urls),
-    path('health/', health_check, name='health_check'),
-    path('api/test-integrations/', test_integrations, name='test_integrations'),
 
+urlpatterns = [
+    path("admin/", admin.site.urls),
+    path("health/", health_check, name="health_check"),
+    path("api/test-integrations/", test_integrations, name="test_integrations"),
     # Bot endpoints
-    path('bot/webhook', CredexCloudApiWebhook.as_view(), name="webhook"),
-    path('bot/notify', CredexSendMessageWebhook.as_view(), name="notify"),
-    path('bot/welcome/message', WelcomeMessage.as_view(), name="welcome_message"),
-    path('bot/wipe', WipeCache.as_view(), name="wipe"),
+    path("bot/webhook", CredexCloudApiWebhook.as_view(), name="webhook"),
+    path("bot/notify", CredexSendMessageWebhook.as_view(), name="notify"),
+    path("bot/welcome/message", WelcomeMessage.as_view(), name="welcome_message"),
+    path("bot/wipe", WipeCache.as_view(), name="wipe"),
 ]
 
 if settings.DEBUG:
     import debug_toolbar  # type: ignore
 
     urlpatterns += [
-        path('__debug__/', include(debug_toolbar.urls)),
+        path("__debug__/", include(debug_toolbar.urls)),
     ]
 
 urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
diff --git a/app/config/wsgi.py b/app/config/wsgi.py
index a9f185c..8509335 100644
--- a/app/config/wsgi.py
+++ b/app/config/wsgi.py
@@ -2,6 +2,6 @@ import os
 
 from django.core.wsgi import get_wsgi_application
 
-os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
 
 application = get_wsgi_application()
diff --git a/app/core/api/api_interactions.py b/app/core/api/api_interactions.py
index 8cee4da..34c5928 100644
--- a/app/core/api/api_interactions.py
+++ b/app/core/api/api_interactions.py
@@ -1,15 +1,14 @@
+import base64
 import logging
-import requests
-import json
-from decouple import config
+from typing import Tuple
 
+import requests
 from core.api.services import CredexBotService
-from ..utils.utils import CredexWhatsappService, wrap_text
+from decouple import config
 from django.core.cache import cache
-import os
-import base64
-from typing import Tuple
+
 from ..config.constants import *
+from ..utils.utils import CredexWhatsappService, wrap_text
 
 logger = logging.getLogger(__name__)
 
@@ -17,8 +16,7 @@ logger = logging.getLogger(__name__)
 class APIInteractions:
     def __init__(self, bot_service: CredexBotService):
         self.bot_service = bot_service
-        self.env = config('ENV', 'dev')  # Default to 'dev' if not set
-        self.base_url = f"{config('MYCREDEX_APP_URL_2')}"
+        self.base_url = f"{config('MYCREDEX_APP_URL')}"
         logger.info(f"Base URL: {self.base_url}")
 
     def refresh_dashboard(self):
@@ -46,9 +43,13 @@ class APIInteractions:
 
         # print("")
         url = f"{self.base_url}/getMemberDashboardByPhone"
-        payload = {"phone": self.bot_service.message['from']}
+        payload = {"phone": self.bot_service.message["from"]}
         headers = self._get_headers()
-        print("\n\n>>>>>>>>>>>>>>>>>>>\n\nHEADERS  >>>> ", headers, self.bot_service.user.state.jwt_token)
+        print(
+            "\n\n>>>>>>>>>>>>>>>>>>>\n\nHEADERS  >>>> ",
+            headers,
+            self.bot_service.user.state.jwt_token,
+        )
 
         self._handle_reset_and_init(reset, silent, init)
         try:
@@ -56,11 +57,19 @@ class APIInteractions:
             print("####### RESPONSE ", response)
             response_data = self._process_api_response(response)
             print("####### RESPONSE DATA ", response_data)
-            if "Member not found" in response_data.get('message', '') or "Could not retrieve member dashboard" in response_data.get('message', '') or "Invalid token" in response_data.get('message', ''):
-                return self.bot_service.action_handler.handle_action_register(register=True)
+            if (
+                "Member not found" in response_data.get("message", "")
+                or "Could not retrieve member dashboard"
+                in response_data.get("message", "")
+                or "Invalid token" in response_data.get("message", "")
+            ):
+                return self.bot_service.action_handler.handle_action_register(
+                    register=True
+                )
             else:
-                return self._handle_successful_refresh(current_state, member_info=response_data)
-
+                return self._handle_successful_refresh(
+                    current_state, member_info=response_data
+                )
 
         except Exception as e:
             logger.exception(f"Error during refresh: {str(e)}")
@@ -73,15 +82,20 @@ class APIInteractions:
         logger.info(f"Login URL: {url}")
         payload = {"phone": self.bot_service.user.mobile_number}
         headers = {
-            'Content-Type': 'application/json',
-            'x-client-api-key': config('WHATSAPP_BOT_API_KEY')
+            "Content-Type": "application/json",
+            "x-client-api-key": config("CLIENT_API_KEY"),
         }
 
         try:
             response = self._make_api_request(url, headers, payload)
             if response.status_code == 200:
                 response_data = response.json()
-                token = response_data.get('data', {}).get('action', {}).get('details', {}).get('token')
+                token = (
+                    response_data.get("data", {})
+                    .get("action", {})
+                    .get("details", {})
+                    .get("token")
+                )
                 if token:
                     self.bot_service.user.state.set_jwt_token(token)
                     logger.info(f"Login successful {token}")
@@ -91,17 +105,32 @@ class APIInteractions:
                     return False, "Login failed: No token received"
             elif response.status_code == 400:
                 logger.info("Login failed: New user or invalid phone")
-                return False, "*Welcome!* \n\nIt looks like you're new here. Let's get you \nset up."
+                return (
+                    False,
+                    "*Welcome!* \n\nIt looks like you're new here. Let's get you \nset up.",
+                )
             elif response.status_code == 401:
-                logger.error(f"Login failed: Unauthorized. Response content: {response.text}")
-                return False, "Login failed: Unauthorized. Please check your credentials."
+                logger.error(
+                    f"Login failed: Unauthorized. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    "Login failed: Unauthorized. Please check your credentials.",
+                )
             elif response.status_code == 404:
-                logger.error(f"Login failed: Not found. Response content: {response.text}")
+                logger.error(
+                    f"Login failed: Not found. Response content: {response.text}"
+                )
                 print("RESPONSE TEXT ", response.json())
                 return False, response.json()
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Login failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Login failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during login: {str(e)}")
             return False, f"Login failed: {str(e)}"
@@ -119,22 +148,41 @@ class APIInteractions:
             if response.status_code == 201:
                 response_data = response.json()
                 print("REGISTRATION RESPONSE DATA ", response_data)
-                if response_data.get("data", {}).get("action", {}).get("details", {}).get('token'):
-                    self.bot_service.user.state.set_jwt_token(response_data.get('token'))
+                if (
+                    response_data.get("data", {})
+                    .get("action", {})
+                    .get("details", {})
+                    .get("token")
+                ):
+                    self.bot_service.user.state.set_jwt_token(
+                        response_data.get("token")
+                    )
                     logger.info("Registration successful")
                     return True, "Registration successful"
                 else:
                     logger.error("Registration response didn't contain a token")
                     return False, "Registration failed: No token received"
             elif response.status_code == 400:
-                logger.error(f"Registration failed: Bad request. Response content: {response.json().get('message')}")
-                return False, f"*Registration failed (400)*:\n\n{response.json().get('message')}"
+                logger.error(
+                    f"Registration failed: Bad request. Response content: {response.json().get('message')}"
+                )
+                return (
+                    False,
+                    f"*Registration failed (400)*:\n\n{response.json().get('message')}",
+                )
             elif response.status_code == 401:
-                logger.error(f"Registration failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Registration failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Registration failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Registration failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Registration failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during registration: {str(e)}")
             return False, f"Registration failed: {str(e)}"
@@ -163,11 +211,17 @@ class APIInteractions:
                     response_data = response.json()
                     logger.info("Dashboard fetched successfully")
                     return True, response_data
-                logger.error(f"Dashboard fetch failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Dashboard fetch failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, {"message": "Dashboard fetch failed: Unauthorized"}
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, {"message": f"Dashboard fetch failed: Unexpected error (status code: {response.status_code})"}
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return False, {
+                    "message": f"Dashboard fetch failed: Unexpected error (status code: {response.status_code})"
+                }
         except Exception as e:
             logger.exception(f"Error during dashboard fetch: {str(e)}")
             return False, {"message": f"Dashboard fetch failed: {str(e)}"}
@@ -187,15 +241,20 @@ class APIInteractions:
             response = self._make_api_request(url, headers, payload, method="POST")
             if response.status_code == 200:
                 response_data = response.json()
-                if not response_data.get('Error'):
+                if not response_data.get("Error"):
                     logger.info("Handle validation successful")
                     return True, response_data
                 else:
                     logger.error("Handle validation failed")
                     return False, response_data
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Handle validation failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Handle validation failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during handle validation: {str(e)}")
             return False, f"Handle validation failed: {str(e)}"
@@ -203,7 +262,7 @@ class APIInteractions:
     def offer_credex(self, payload):
         """Sends an offer to the CredEx API"""
         logger.info("Attempting to offer CredEx")
-        payload.pop('full_name', None)
+        payload.pop("full_name", None)
 
         url = f"{self.base_url}/createCredex"
         logger.info(f"Offer URL: {url}")
@@ -214,21 +273,33 @@ class APIInteractions:
             if response.status_code == 200:
                 response_data = response.json()
 
-                if response_data.get('data', {}).get('action', {}).get('type') == "CREDEX_CREATED":
+                if (
+                    response_data.get("data", {}).get("action", {}).get("type")
+                    == "CREDEX_CREATED"
+                ):
                     logger.info("Offer successful")
                     return True, response_data
                 else:
                     logger.error("Offer failed")
-                    return False, response_data.get('error')
+                    return False, response_data.get("error")
             elif response.status_code == 400:
-                logger.error(f"Offer failed: Bad request. Response content: {response.json().get('message')}")
-                return False, response.json().get('error')
+                logger.error(
+                    f"Offer failed: Bad request. Response content: {response.json().get('message')}"
+                )
+                return False, response.json().get("error")
             elif response.status_code == 401:
-                logger.error(f"Offer failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Offer failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Offer failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Offer failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Offer failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during offer: {str(e)}")
             return False, f"Offer failed: {str(e)}"
@@ -245,21 +316,30 @@ class APIInteractions:
             response = self._make_api_request(url, headers, payload)
             if response.status_code == 200:
                 response_data = response.json()
-                if response_data.get('summary', {}).get("accepted"):
+                if response_data.get("summary", {}).get("accepted"):
                     logger.info("Accept successful")
                     return True, response_data
                 else:
                     logger.error("Accept failed")
-                    return False, response_data.get('error')
+                    return False, response_data.get("error")
             elif response.status_code == 400:
-                logger.error(f"Accept failed: Bad request. Response content: {response.json().get('message')}")
+                logger.error(
+                    f"Accept failed: Bad request. Response content: {response.json().get('message')}"
+                )
                 return False, f"Accept failed: {response.json().get('message')}"
             elif response.status_code == 401:
-                logger.error(f"Accept failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Accept failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Accept failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Accept failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Accept failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during accept: {str(e)}")
             return False, f"Accept failed: {str(e)}"
@@ -277,21 +356,36 @@ class APIInteractions:
             response = self._make_api_request(url, headers, payload)
             if response.status_code == 200:
                 response_data = response.json()
-                if response_data.get('data', {}).get('action', {}).get('type') == "CREDEX_ACCEPTED":
+                if (
+                    response_data.get("data", {}).get("action", {}).get("type")
+                    == "CREDEX_ACCEPTED"
+                ):
                     logger.info("Accept successful")
                     return True, response_data
                 else:
                     logger.error("Accept failed")
-                    return False, response_data.get('error')
+                    return False, response_data.get("error")
             elif response.status_code == 400:
-                logger.error(f"Accept failed: Bad request. Response content: {response.json().get('message')}")
-                return False, f"Accept failed: {response.json().get('error', 'Failed to accept')}"
+                logger.error(
+                    f"Accept failed: Bad request. Response content: {response.json().get('message')}"
+                )
+                return (
+                    False,
+                    f"Accept failed: {response.json().get('error', 'Failed to accept')}",
+                )
             elif response.status_code == 401:
-                logger.error(f"Accept failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Accept failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Accept failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Accept failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Accept failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during accept: {str(e)}")
             return False, f"Accept failed: {str(e)}"
@@ -308,21 +402,30 @@ class APIInteractions:
             response = self._make_api_request(url, headers, payload)
             if response.status_code == 200:
                 response_data = response.json()
-                if response_data.get('status') == 'success':
+                if response_data.get("status") == "success":
                     logger.info("Decline successful")
                     return True, "Decline successful"
                 else:
                     logger.error("Decline failed")
-                    return False, response_data.get('error')
+                    return False, response_data.get("error")
             elif response.status_code == 400:
-                logger.error(f"Decline failed: Bad request. Response content: {response.json().get('message')}")
+                logger.error(
+                    f"Decline failed: Bad request. Response content: {response.json().get('message')}"
+                )
                 return False, f"Decline failed: {response.json().get('message')}"
             elif response.status_code == 401:
-                logger.error(f"Decline failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Decline failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Decline failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Decline failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Decline failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during decline: {str(e)}")
             return False, f"Decline failed: {str(e)}"
@@ -340,21 +442,30 @@ class APIInteractions:
             response = self._make_api_request(url, headers, payload)
             if response.status_code == 200:
                 response_data = response.json()
-                if response_data.get('message') == 'Credex cancelled successfully':
+                if response_data.get("message") == "Credex cancelled successfully":
                     logger.info("Cancel successful")
                     return True, "Credex cancelled successfully"
                 else:
                     logger.error("Cancel failed")
-                    return False, response_data.get('error')
+                    return False, response_data.get("error")
             elif response.status_code == 400:
-                logger.error(f"Cancel failed: Bad request. Response content: {response.json().get('message')}")
+                logger.error(
+                    f"Cancel failed: Bad request. Response content: {response.json().get('message')}"
+                )
                 return False, f"Cancel failed: {response.json().get('message')}"
             elif response.status_code == 401:
-                logger.error(f"Cancel failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Cancel failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Cancel failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Cancel failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Cancel failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during cancel: {str(e)}")
             return False, f"Cancel failed: {str(e)}"
@@ -377,14 +487,23 @@ class APIInteractions:
                 logger.info("Credex fetched successfully")
                 return True, response_data
             elif response.status_code == 400:
-                logger.error(f"Credex fetch failed: Bad request. Response content: {response.json().get('message')}")
+                logger.error(
+                    f"Credex fetch failed: Bad request. Response content: {response.json().get('message')}"
+                )
                 return False, f"Credex fetch failed: {response.json().get('message')}"
             elif response.status_code == 401:
-                logger.error(f"Credex fetch failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Credex fetch failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Credex fetch failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Credex fetch failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Credex fetch failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during credex fetch: {str(e)}")
             return False, f"Credex fetch failed: {str(e)}"
@@ -406,14 +525,23 @@ class APIInteractions:
                 logger.info("Ledger fetched successfully")
                 return True, response_data
             elif response.status_code == 400:
-                logger.error(f"Ledger fetch failed: Bad request. Response content: {response.json().get('message')}")
+                logger.error(
+                    f"Ledger fetch failed: Bad request. Response content: {response.json().get('message')}"
+                )
                 return False, f"Ledger fetch failed: {response.json().get('message')}"
             elif response.status_code == 401:
-                logger.error(f"Ledger fetch failed: Unauthorized. Response content: {response.text}")
+                logger.error(
+                    f"Ledger fetch failed: Unauthorized. Response content: {response.text}"
+                )
                 return False, f"Ledger fetch failed: Unauthorized. {response.text}"
             else:
-                logger.error(f"Unexpected status code: {response.status_code}. Response content: {response.text}")
-                return False, f"Ledger fetch failed: Unexpected error (status code: {response.status_code})"
+                logger.error(
+                    f"Unexpected status code: {response.status_code}. Response content: {response.text}"
+                )
+                return (
+                    False,
+                    f"Ledger fetch failed: Unexpected error (status code: {response.status_code})",
+                )
         except Exception as e:
             logger.exception(f"Error during ledger fetch: {str(e)}")
             return False, f"Ledger fetch failed: {str(e)}"
@@ -422,19 +549,21 @@ class APIInteractions:
     @staticmethod
     def _get_basic_auth_header(phone_number):
         credentials = f"{phone_number}:{phone_number}"
-        encoded_credentials = base64.b64encode(credentials.encode('utf-8')).decode('utf-8')
+        encoded_credentials = base64.b64encode(credentials.encode("utf-8")).decode(
+            "utf-8"
+        )
         return f"Basic {encoded_credentials}"
 
     def _get_headers(self):
         user = CachedUser(self.bot_service.user.mobile_number)
         headers = {
-            'Content-Type': 'application/json',
-            'x-client-api-key': config('WHATSAPP_BOT_API_KEY'),
+            "Content-Type": "application/json",
+            "x-client-api-key": config("CLIENT_API_KEY"),
         }
 
         # Add JWT token if available
         if user.jwt_token:
-            headers['Authorization'] = f"Bearer {user.jwt_token}"
+            headers["Authorization"] = f"Bearer {user.jwt_token}"
         else:
             self.login()
 
@@ -448,28 +576,35 @@ class APIInteractions:
 
     def _send_delay_message(self):
         if self.bot_service.state.stage != "handle_action_register" and not cache.get(
-                f"{self.bot_service.user.mobile_number}_interracted"):
-            CredexWhatsappService(payload={
+            f"{self.bot_service.user.mobile_number}_interracted"
+        ):
+            CredexWhatsappService(
+                payload={
                     "messaging_product": "whatsapp",
                     "preview_url": False,
                     "recipient_type": "individual",
                     "to": self.bot_service.user.mobile_number,
                     "type": "text",
-                "text": {"body": "Please wait while we process your request..."}
-            }).send_message()
-            cache.set(f"{self.bot_service.user.mobile_number}_interracted", True, 60 * 15)
+                    "text": {"body": "Please wait while we process your request..."},
+                }
+            ).send_message()
+            cache.set(
+                f"{self.bot_service.user.mobile_number}_interracted", True, 60 * 15
+            )
 
     def _send_first_message(self):
         # Instead of fetching from the database, we'll use a hardcoded message
         first_message = "Welcome to CredEx! How can I assist you today?"
-        CredexWhatsappService(payload={
+        CredexWhatsappService(
+            payload={
                 "messaging_product": "whatsapp",
                 "preview_url": False,
                 "recipient_type": "individual",
                 "to": self.bot_service.user.mobile_number,
                 "type": "text",
-            "text": {"body": first_message}
-        }).send_message()
+                "text": {"body": first_message},
+            }
+        ).send_message()
 
     def _make_api_request(self, url, headers, payload, method="POST", login=False):
         logger.info(f"Sending API request to: {url}")
@@ -482,11 +617,13 @@ class APIInteractions:
             if not success:
                 return message
 
-        headers['Authorization'] = f"Bearer {user.jwt_token}"
+        headers["Authorization"] = f"Bearer {user.jwt_token}"
         response = requests.request(method, url, headers=headers, json=payload)
         logger.info(f"API Response Status Code: {response.status_code}")
         logger.info(f"API Response Headers: {response.headers}")
-        logger.info(f"API Response Content: {response.text[:500]}...")  # Log only the first 500 characters
+        logger.info(
+            f"API Response Content: {response.text[:500]}..."
+        )  # Log only the first 500 characters
         return response
 
     @staticmethod
@@ -494,8 +631,8 @@ class APIInteractions:
         # if response.status_code != 200:
         #     raise requests.exceptions.RequestException(f"API returned status code {response.status_code}")
 
-        content_type = response.headers.get('Content-Type', '')
-        if 'application/json' not in content_type:
+        content_type = response.headers.get("Content-Type", "")
+        if "application/json" not in content_type:
             raise ValueError(f"Received unexpected Content-Type: {content_type}")
 
         return response.json()
@@ -503,9 +640,9 @@ class APIInteractions:
     @staticmethod
     def _update_current_state(response_data, current_state, reset):
         if reset:
-            current_state['profile'] = response_data
+            current_state["profile"] = response_data
         else:
-            current_state['profile'].update(response_data)
+            current_state["profile"].update(response_data)
         logger.info("Current state updated")
 
     def _handle_successful_refresh(self, current_state, member_info=dict):
@@ -581,37 +718,47 @@ class APIInteractions:
         # }
 
         member_info = {
-            'member': member_info.get('data', {}).get('action', {}).get('details', {}),
-            'memberDashboard': member_info.get('data', {}).get('dashboard')
+            "member": member_info.get("data", {}).get("action", {}).get("details", {}),
+            "memberDashboard": member_info.get("data", {}).get("dashboard"),
         }
 
-
         user = CachedUser(self.bot_service.user.mobile_number)
         if member_info:
-            current_state['profile'] = member_info
-            if not current_state.get('current_account', {}):
-                if current_state.get('profile', {}).get('memberDashboard', {}).get('memberTier', {}).get('low', 1) < 2:
+            current_state["profile"] = member_info
+            if not current_state.get("current_account", {}):
+                if (
+                    current_state.get("profile", {})
+                    .get("memberDashboard", {})
+                    .get("memberTier", {})
+                    .get("low", 1)
+                    < 2
+                ):
                     try:
-                        current_state.update({'current_account': member_info['memberDashboard']['accounts'][0]})
+                        current_state.update(
+                            {
+                                "current_account": member_info["memberDashboard"][
+                                    "accounts"
+                                ][0]
+                            }
+                        )
                     except Exception as e:
                         print("ERROR SETTING DEFAULT PROFILE ", e)
-                        current_state['current_account'] = {}
+                        current_state["current_account"] = {}
                 else:
-                    current_state['current_account'] = {}
-                
+                    current_state["current_account"] = {}
 
         user.state.update_state(
             state=current_state,
-            stage='handle_action_menu',
+            stage="handle_action_menu",
             update_from="refresh",
-            option="handle_action_menu"
+            option="handle_action_menu",
         )
 
         self.bot_service.state_manager.update_state(
             new_state=current_state,
             update_from="handle_action_menu",
-            stage='handle_action_register',
-            option="handle_action_register"
+            stage="handle_action_register",
+            option="handle_action_register",
         )
         return None
 
@@ -620,11 +767,13 @@ class APIInteractions:
         user = CachedUser(self.bot_service.user.mobile_number)
         user.state.update_state(
             state=current_state,
-            stage='handle_action_register',
+            stage="handle_action_register",
             update_from="refresh",
-            option="handle_action_register"
+            option="handle_action_register",
         )
-        return wrap_text(f"An error occurred: {error_message}. Please try again.",
+        return wrap_text(
+            f"An error occurred: {error_message}. Please try again.",
             self.bot_service.user.mobile_number,
-                         extra_rows=[{"id": '1', "title": "Become a member"}],
-                         include_menu=False)
+            extra_rows=[{"id": "1", "title": "Become a member"}],
+            include_menu=False,
+        )
diff --git a/app/core/api/services.py b/app/core/api/services.py
index 9429243..c013285 100644
--- a/app/core/api/services.py
+++ b/app/core/api/services.py
@@ -12,7 +13,7 @@ class CredexBotService:
     def __init__(self, payload, methods: dict = dict, user: object = None) -> None:
         self.message = payload
         self.user = user
-        self.body = self.message['message']
+        self.body = self.message["message"]
 
         # Load
         self.user = CachedUser(self.user)
@@ -46,8 +47,22 @@ class CredexBotService:
 
         return formatted_synopsis.strip()
 
-    def wrap_text(self, message, proceed_option=False, x_is_menu=False, include_back=False, navigate_is="Respond",
-                  extra_rows=[], number=None, back_is_cancel=False, use_buttons=False, yes_or_no=False, custom={}, plain=False, include_menu=True):
+    def wrap_text(
+        self,
+        message,
+        proceed_option=False,
+        x_is_menu=False,
+        include_back=False,
+        navigate_is="Respond",
+        extra_rows=[],
+        number=None,
+        back_is_cancel=False,
+        use_buttons=False,
+        yes_or_no=False,
+        custom={},
+        plain=False,
+        include_menu=True,
+    ):
         """THIS METHOD HANDLES ABSTRACTS CLOUDAPI MESSAGE DETAILS"""
         # ... (rest of the method implementation)
 
diff --git a/app/core/api/tests.py b/app/core/api/tests.py
index 51752a3..772fec1 100644
--- a/app/core/api/tests.py
+++ b/app/core/api/tests.py
@@ -12,32 +13,29 @@ def test_integrations(request):
     Test endpoint to verify all integrations are working correctly.
     GET /api/test-integrations/
     """
-    results = {
-        'status': 'running',
-        'tests': {}
-    }
+    results = {"status": "running", "tests": {}}
 
     # Test 1: Django Setup
-    results['tests']['django'] = {
-        'status': 'success',
-        'message': 'Django is running correctly'
+    results["tests"]["django"] = {
+        "status": "success",
+        "message": "Django is running correctly",
     }
 
     # Test 2: Redis Connection
     try:
-        cache.set('test_key', 'test_value', 10)
-        test_value = cache.get('test_key')
-        if test_value == 'test_value':
-            results['tests']['redis'] = {
-                'status': 'success',
-                'message': 'Redis connection successful'
+        cache.set("test_key", "test_value", 10)
+        test_value = cache.get("test_key")
+        if test_value == "test_value":
+            results["tests"]["redis"] = {
+                "status": "success",
+                "message": "Redis connection successful",
             }
         else:
-            raise Exception('Redis get/set test failed')
+            raise Exception("Redis get/set test failed")
     except Exception as e:
-        results['tests']['redis'] = {
-            'status': 'error',
-            'message': f'Redis connection failed: {str(e)}'
+        results["tests"]["redis"] = {
+            "status": "error",
+            "message": f"Redis connection failed: {str(e)}",
         }
 
     # Test 3: Credex Core API
@@ -45,50 +43,55 @@ def test_integrations(request):
         api_url = f"{config('MYCREDEX_APP_URL')}v1/health"
         response = requests.get(api_url)
         if response.status_code == 200:
-            results['tests']['credex_api'] = {
-                'status': 'success',
-                'message': 'Credex Core API connection successful'
+            results["tests"]["credex_api"] = {
+                "status": "success",
+                "message": "Credex Core API connection successful",
             }
         else:
-            raise Exception(f'API returned status code {response.status_code}')
+            raise Exception(f"API returned status code {response.status_code}")
     except Exception as e:
-        results['tests']['credex_api'] = {
-            'status': 'error',
-            'message': f'Credex Core API connection failed: {str(e)}'
+        results["tests"]["credex_api"] = {
+            "status": "error",
+            "message": f"Credex Core API connection failed: {str(e)}",
         }
 
     # Test 4: WhatsApp API
     try:
         # Create a test message that won't actually be sent
-        test_service = CredexWhatsappService({
+        test_service = CredexWhatsappService(
+            {
                 "messaging_product": "whatsapp",
                 "recipient_type": "individual",
                 "to": "test",
                 "type": "text",
-            "text": {"body": "test"}
-        }, config('WHATSAPP_PHONE_NUMBER_ID'))
+                "text": {"body": "test"},
+            },
+            config("WHATSAPP_PHONE_NUMBER_ID"),
+        )
 
         # Just verify we can construct the URL and headers
-        url = f"{config('WHATSAPP_API_URL')}{config('WHATSAPP_PHONE_NUMBER_ID')}/messages"
+        url = (
+            f"{config('WHATSAPP_API_URL')}{config('WHATSAPP_PHONE_NUMBER_ID')}/messages"
+        )
         headers = {
-            'Authorization': f"Bearer {config('WHATSAPP_ACCESS_TOKEN')}",
-            'Content-Type': 'application/json'
+            "Authorization": f"Bearer {config('WHATSAPP_ACCESS_TOKEN')}",
+            "Content-Type": "application/json",
         }
 
-        results['tests']['whatsapp'] = {
-            'status': 'success',
-            'message': 'WhatsApp configuration verified'
+        results["tests"]["whatsapp"] = {
+            "status": "success",
+            "message": "WhatsApp configuration verified",
         }
     except Exception as e:
-        results['tests']['whatsapp'] = {
-            'status': 'error',
-            'message': f'WhatsApp configuration error: {str(e)}'
+        results["tests"]["whatsapp"] = {
+            "status": "error",
+            "message": f"WhatsApp configuration error: {str(e)}",
         }
 
     # Overall status
-    if all(test['status'] == 'success' for test in results['tests'].values()):
-        results['status'] = 'success'
+    if all(test["status"] == "success" for test in results["tests"].values()):
+        results["status"] = "success"
     else:
-        results['status'] = 'error'
+        results["status"] = "error"
 
     return JsonResponse(results)
diff --git a/app/core/api/views.py b/app/core/api/views.py
index 19d3a24..6c1520b 100644
--- a/app/core/api/views.py
+++ b/app/core/api/views.py
@@ -1,17 +1,18 @@
 import json
-import requests
-from rest_framework.views import APIView
-from django.http import JsonResponse, HttpResponse
-from rest_framework import status
-from rest_framework.parsers import JSONParser
-from decouple import config
 from datetime import datetime
 
+import requests
+from core.api.models import Message
+from core.config.constants import CachedUser
+
 # Use absolute imports
 from core.message_handling.credex_bot_service import CredexBotService
-from core.config.constants import CachedUser
 from core.utils.utils import CredexWhatsappService
-from core.api.models import Message
+from decouple import config
+from django.http import HttpResponse, JsonResponse
+from rest_framework import status
+from rest_framework.parsers import JSONParser
+from rest_framework.views import APIView
 
 
 class CredexCloudApiWebhook(APIView):
@@ -21,124 +23,156 @@ class CredexCloudApiWebhook(APIView):
 
     @staticmethod
     def post(request):
-        payload = request.data.get('entry')[0].get('changes')[0].get('value')
+        payload = request.data.get("entry")[0].get("changes")[0].get("value")
         # print("INCOMING >> ", request.data)
 
-        if payload['metadata']['phone_number_id'] != config('WHATSAPP_PHONE_NUMBER_ID'):
+        if payload["metadata"]["phone_number_id"] != config("WHATSAPP_PHONE_NUMBER_ID"):
             # print(payload['metadata']['phone_number_id'])
             return JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
-        if payload.get('messages'):
-            phone_number_id = payload['metadata'].get('phone_number_id')
-            message = payload['messages'][0]
-            message_type = message['type']
-            contact = payload['contacts'][0] if message_type != "system" else payload['messages'][0].get("wa_id")
-
-            if message_type == "system" or message.get('system') or phone_number_id != config(
-                    'WHATSAPP_PHONE_NUMBER_ID'):
+        if payload.get("messages"):
+            phone_number_id = payload["metadata"].get("phone_number_id")
+            message = payload["messages"][0]
+            message_type = message["type"]
+            contact = (
+                payload["contacts"][0]
+                if message_type != "system"
+                else payload["messages"][0].get("wa_id")
+            )
+
+            if (
+                message_type == "system"
+                or message.get("system")
+                or phone_number_id != config("WHATSAPP_PHONE_NUMBER_ID")
+            ):
                 JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
 
             if message_type == "text":
-                payload['body'] = message['text']['body']
+                payload["body"] = message["text"]["body"]
 
             elif message_type == "button":
-                payload['body'] = message['button']['payload']
+                payload["body"] = message["button"]["payload"]
 
             elif message_type == "interactive":
-                if message.get('interactive'):
-                    if message['interactive']['type'] == "button_reply":
-                        payload['body'] = message['interactive']['button_reply']['id']
-                    elif message['interactive'].get('type') == "nfm_reply":
+                if message.get("interactive"):
+                    if message["interactive"]["type"] == "button_reply":
+                        payload["body"] = message["interactive"]["button_reply"]["id"]
+                    elif message["interactive"].get("type") == "nfm_reply":
                         message_type = "nfm_reply"
-                        payload['body'] = json.loads(message['interactive']['nfm_reply']['response_json'])
+                        payload["body"] = json.loads(
+                            message["interactive"]["nfm_reply"]["response_json"]
+                        )
                     else:
-                        payload['body'] = message['interactive']['list_reply']['id']
+                        payload["body"] = message["interactive"]["list_reply"]["id"]
                 else:
-                    return JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
+                    return JsonResponse(
+                        {"message": "received"}, status=status.HTTP_200_OK
+                    )
             elif message_type == "location":
-                payload['body'] = (message['location']['latitude'], message['location']['longitude'])
+                payload["body"] = (
+                    message["location"]["latitude"],
+                    message["location"]["longitude"],
+                )
 
             elif message_type == "image":
-                image_id = message['image']['id']
-                headers = {
-                    'Authorization': 'Bearer ' + config('WHATSAPP_ACCESS_TOKEN')
-                }
+                image_id = message["image"]["id"]
+                headers = {"Authorization": "Bearer " + config("WHATSAPP_ACCESS_TOKEN")}
                 file = requests.request(
-                    "GET", url=f"https://graph.facebook.com/v18.0/{image_id}", headers=headers, data={}).json()
-
-                caption = message['image'].get('caption')
-                payload['file_id'] = image_id
+                    "GET",
+                    url=f"https://graph.facebook.com/v18.0/{image_id}",
+                    headers=headers,
+                    data={},
+                ).json()
+
+                caption = message["image"].get("caption")
+                payload["file_id"] = image_id
                 if caption:
-                    payload['caption'] = caption
-                payload['body'] = file.get('url')
-                payload['file_name'] = file.get('name')
+                    payload["caption"] = caption
+                payload["body"] = file.get("url")
+                payload["file_name"] = file.get("name")
 
             elif message_type == "document":
-                document_id = message['document']['id']
-                headers = {
-                    'Authorization': 'Bearer ' + config('WHATSAPP_ACCESS_TOKEN')
-                }
+                document_id = message["document"]["id"]
+                headers = {"Authorization": "Bearer " + config("WHATSAPP_ACCESS_TOKEN")}
                 file = requests.request(
-                    "GET", url=f"https://graph.facebook.com/v18.0/{document_id}", headers=headers,
-                    data={}).json()
-                payload['body'] = file.get('url')
-                payload['file_name'] = file.get('name')
-                payload['file_id'] = document_id
+                    "GET",
+                    url=f"https://graph.facebook.com/v18.0/{document_id}",
+                    headers=headers,
+                    data={},
+                ).json()
+                payload["body"] = file.get("url")
+                payload["file_name"] = file.get("name")
+                payload["file_id"] = document_id
 
             elif message_type == "video":
-                video_id = message['video']['id']
-                headers = {
-                    'Authorization': 'Bearer ' + config('WHATSAPP_ACCESS_TOKEN')
-                }
+                video_id = message["video"]["id"]
+                headers = {"Authorization": "Bearer " + config("WHATSAPP_ACCESS_TOKEN")}
                 file = requests.request(
-                    "GET", url=f"https://graph.facebook.com/v18.0/{video_id}", headers=headers, data={}).json()
-                payload['body'] = file.get('url')
-                payload['file_name'] = file.get('name')
-                payload['file_id'] = video_id
-                caption = message['video'].get('caption')
+                    "GET",
+                    url=f"https://graph.facebook.com/v18.0/{video_id}",
+                    headers=headers,
+                    data={},
+                ).json()
+                payload["body"] = file.get("url")
+                payload["file_name"] = file.get("name")
+                payload["file_id"] = video_id
+                caption = message["video"].get("caption")
                 if caption:
-                    payload['caption'] = caption
+                    payload["caption"] = caption
             elif message_type == "audio":
-                audio_id = message['audio']['id']
-                headers = {
-                    'Authorization': 'Bearer ' + config('WHATSAPP_ACCESS_TOKEN')
-                }
+                audio_id = message["audio"]["id"]
+                headers = {"Authorization": "Bearer " + config("WHATSAPP_ACCESS_TOKEN")}
                 file = requests.request(
-                    "GET", url=f"https://graph.facebook.com/v18.0/{audio_id}", headers=headers, data={}).json()
-                payload['body'] = file.get('url')
-                payload['file_name'] = file.get('name')
+                    "GET",
+                    url=f"https://graph.facebook.com/v18.0/{audio_id}",
+                    headers=headers,
+                    data={},
+                ).json()
+                payload["body"] = file.get("url")
+                payload["file_name"] = file.get("name")
 
             elif message_type == "order":
-                payload['body'] = message['order']['product_items']
+                payload["body"] = message["order"]["product_items"]
 
             elif message_type == "nfm_reply":
-                payload['body'] = message['nfm_reply']['response_json']
+                payload["body"] = message["nfm_reply"]["response_json"]
 
             if f"{payload['body']}".lower() in ["ok", "thanks", "thank you"]:
-                CredexWhatsappService(payload={
+                CredexWhatsappService(
+                    payload={
                         "messaging_product": "whatsapp",
                         "recipient_type": "individual",
-                    "to": contact['wa_id'],
+                        "to": contact["wa_id"],
                         "type": "text",
-                    "text": {
-                        "body": '🙏'
-                    }
-                }, phone_number_id=payload['metadata']['phone_number_id']).notify()
+                        "text": {"body": "🙏"},
+                    },
+                    phone_number_id=payload["metadata"]["phone_number_id"],
+                ).notify()
 
                 return JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
 
             elif message_type == "reaction":
-                payload['body'] = message['reaction'].get('emoji')
-                if f"{payload['body']}".lower() in ["👍", "🙏", "❤️", "ok", "thanks", "thank you"]:
-                    CredexWhatsappService(payload={
+                payload["body"] = message["reaction"].get("emoji")
+                if f"{payload['body']}".lower() in [
+                    "👍",
+                    "🙏",
+                    "❤️",
+                    "ok",
+                    "thanks",
+                    "thank you",
+                ]:
+                    CredexWhatsappService(
+                        payload={
                             "messaging_product": "whatsapp",
                             "recipient_type": "individual",
-                        "to": contact['wa_id'],
+                            "to": contact["wa_id"],
                             "type": "text",
-                        "text": {
-                            "body": '🙏'
-                        }
-                    }, phone_number_id=payload['metadata']['phone_number_id']).notify()
-                    return JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
+                            "text": {"body": "🙏"},
+                        },
+                        phone_number_id=payload["metadata"]["phone_number_id"],
+                    ).notify()
+                    return JsonResponse(
+                        {"message": "received"}, status=status.HTTP_200_OK
+                    )
 
             if not contact:
                 return JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
@@ -146,34 +180,40 @@ class CredexCloudApiWebhook(APIView):
             # print("||||||||>>>>>>")
             # Format the message
             formatted_message = {
-                "to": payload['metadata']['display_phone_number'],
-                "phone_number_id": payload['metadata']['phone_number_id'],
-                "from": contact['wa_id'],
-                "username": contact['profile']['name'],
+                "to": payload["metadata"]["display_phone_number"],
+                "phone_number_id": payload["metadata"]["phone_number_id"],
+                "from": contact["wa_id"],
+                "username": contact["profile"]["name"],
                 "type": message_type,
-                "message": payload['body'],
-                "filename": payload.get('file_name', None),
-                "fileid": payload.get('file_id', None),
-                "caption": payload.get('caption', None),
+                "message": payload["body"],
+                "filename": payload.get("file_name", None),
+                "fileid": payload.get("file_id", None),
+                "caption": payload.get("caption", None),
             }
-            user = CachedUser(formatted_message.get('from'))
+            user = CachedUser(formatted_message.get("from"))
             state = user.state
 
             # Calculate the time difference in seconds
-            message_stamp = datetime.fromtimestamp(int(message['timestamp']))
+            message_stamp = datetime.fromtimestamp(int(message["timestamp"]))
             if (datetime.now() - message_stamp).total_seconds() > 20:
                 print("IGNORING OLD HOOK ", message_stamp)
                 return JsonResponse({"message": "received"}, status=status.HTTP_200_OK)
 
-            print(f"Credex {state.stage}<|>{state.option}] RECEIVED - > ", payload['body'], " FROM ",
-                  formatted_message.get('from'), " @ ", message_stamp,
-                  f"({(datetime.now() - message_stamp).total_seconds()} sec ago)")
+            print(
+                f"Credex {state.stage}<|>{state.option}] RECEIVED - > ",
+                payload["body"],
+                " FROM ",
+                formatted_message.get("from"),
+                " @ ",
+                message_stamp,
+                f"({(datetime.now() - message_stamp).total_seconds()} sec ago)",
+            )
 
             try:
                 service = CredexBotService(payload=formatted_message, user=user)
                 CredexWhatsappService(
                     payload=service.response,
-                    phone_number_id=payload['metadata']['phone_number_id']
+                    phone_number_id=payload["metadata"]["phone_number_id"],
                 ).send_message()
             except Exception as e:
                 print(e)
@@ -184,7 +224,7 @@ class CredexCloudApiWebhook(APIView):
 
     def get(self, request, *args, **kwargs):
         print(request.query_params)
-        return HttpResponse(request.query_params.get('hub.challenge'), 200)
+        return HttpResponse(request.query_params.get("hub.challenge"), 200)
 
 
 class WelcomeMessage(APIView):
@@ -193,12 +234,12 @@ class WelcomeMessage(APIView):
 
     @staticmethod
     def post(request):
-        if request.data.get('message'):
+        if request.data.get("message"):
             if not Message.objects.all().first():
-                Message.objects.create(messsage=request.data.get('message'))
+                Message.objects.create(messsage=request.data.get("message"))
             else:
                 obj = Message.objects.all().first()
-                obj.messsage = request.data.get('message')
+                obj.messsage = request.data.get("message")
                 obj.save()
         return JsonResponse({"message": "Success"}, status=status.HTTP_200_OK)
 
@@ -221,38 +264,45 @@ class CredexSendMessageWebhook(APIView):
 
     @staticmethod
     def post(request):
-        if request.headers.get('whatsappBotAPIkey') == config('WHATSAPP_BOT_API_KEY') or request.headers.get(
-                'Whatsappbotapikey') == config('WHATSAPP_BOT_API_KEY'):
-            if request.data.get('phoneNumber') and request.data.get('memberName') and request.data.get('message'):
+        if (
+            request.headers.get("whatsappBotAPIkey", "").lower()
+            == config("CLIENT_API_KEY").lower()
+        ):
+            if (
+                request.data.get("phoneNumber")
+                and request.data.get("memberName")
+                and request.data.get("message")
+            ):
                 payload = {
                     "messaging_product": "whatsapp",
                     "recipient_type": "individual",
-                    "to": request.data.get('phoneNumber'),
+                    "to": request.data.get("phoneNumber"),
                     "type": "template",
                     "template": {
                         "name": "incoming_notification",
-                        "language": {
-                            "code": "en_US"
-                        },
+                        "language": {"code": "en_US"},
                         "components": [
                             {
                                 "type": "body",
                                 "parameters": [
                                     {
                                         "type": "text",
-                                        "text": request.data.get('memberName')
+                                        "text": request.data.get("memberName"),
                                     },
                                     {
                                         "type": "text",
-                                        "text": request.data.get('message')
-                                    }
-                                ]
-                            }
-                        ]
+                                        "text": request.data.get("message"),
+                                    },
+                                ],
                             }
+                        ],
+                    },
                 }
 
                 response = CredexWhatsappService(payload=payload).notify()
                 print("RESPONSE : ", response)
                 return JsonResponse(response, status=status.HTTP_200_OK)
-        return JsonResponse({"status": "Successful", "message": "Missing API KEY"}, status=status.HTTP_400_BAD_REQUEST)
+        return JsonResponse(
+            {"status": "Successful", "message": "Missing API KEY"},
+            status=status.HTTP_400_BAD_REQUEST,
+        )
diff --git a/app/core/config/apps.py b/app/core/config/apps.py
index 8115ae6..c0ce093 100644
--- a/app/core/config/apps.py
+++ b/app/core/config/apps.py
@@ -2,5 +2,5 @@ from django.apps import AppConfig
 
 
 class CoreConfig(AppConfig):
-    default_auto_field = 'django.db.models.BigAutoField'
-    name = 'core'
+    default_auto_field = "django.db.models.BigAutoField"
+    name = "core"
diff --git a/app/core/config/constants.py b/app/core/config/constants.py
index 49b3a46..1524261 100644
--- a/app/core/config/constants.py
+++ b/app/core/config/constants.py
@@ -20,7 +20,7 @@ GREETINGS = [
     "hey",
     "y",
     "yes",
-    "retry"
+    "retry",
 ]
 
 import datetime
@@ -50,7 +50,9 @@ class CachedUserState:
         self.state = cache.get(f"{self.user.mobile_number}", {})
         self.jwt_token = cache.get(f"{self.user.mobile_number}_jwt_token")
 
-    def update_state(self, state: dict, update_from, stage=None, option=None, direction=None):
+    def update_state(
+        self, state: dict, update_from, stage=None, option=None, direction=None
+    ):
         """Get wallets by user."""
         # pylint: disable=no-member
         # print("UPDATING FROM ", update_from, stage, option, direction, state)
@@ -77,7 +79,7 @@ class CachedUserState:
 
     def reset_state(self):
         state = cache.get(f"{self.user.mobile_number}", {})
-        state['state'] = {}
+        state["state"] = {}
         cache.set(f"{self.user.mobile_number}_stage", "handle_action_menu")
         cache.delete(f"{self.user.mobile_number}_option")
         cache.set(f"{self.user.mobile_number}", {}, timeout=60 * 5)
@@ -99,34 +101,33 @@ class CachedUser:
 
 
 MENU_OPTIONS_1 = {
-    '1': "handle_action_offer_credex",
-    'handle_action_offer_credex': "handle_action_offer_credex",
-    '2': "handle_action_pending_offers_in",
-    'handle_action_pending_offers_in': "handle_action_pending_offers_in",
-    '3': "handle_action_pending_offers_out",
-    'handle_action_pending_offers_out': "handle_action_pending_offers_out",
-    '4': "handle_action_transactions",
-    'handle_action_transactions': "handle_action_transactions",
-    '5': "handle_action_switch_account",
-    'handle_action_switch_account': "handle_action_switch_account",
+    "1": "handle_action_offer_credex",
+    "handle_action_offer_credex": "handle_action_offer_credex",
+    "2": "handle_action_pending_offers_in",
+    "handle_action_pending_offers_in": "handle_action_pending_offers_in",
+    "3": "handle_action_pending_offers_out",
+    "handle_action_pending_offers_out": "handle_action_pending_offers_out",
+    "4": "handle_action_transactions",
+    "handle_action_transactions": "handle_action_transactions",
+    "5": "handle_action_switch_account",
+    "handle_action_switch_account": "handle_action_switch_account",
 }
 
 MENU_OPTIONS_2 = {
-    '1': "handle_action_offer_credex",
-    'handle_action_offer_credex': "handle_action_offer_credex",
-    '2': "handle_action_pending_offers_in",
-    'handle_action_pending_offers_in': "handle_action_pending_offers_in",
-    '3': "handle_action_pending_offers_out",
-    'handle_action_pending_offers_out': "handle_action_pending_offers_out",
-    '4': "handle_action_transactions",
-    'handle_action_transactions': "handle_action_transactions",
-    '5': "handle_action_authorize_member",
-    'handle_action_authorize_member': "handle_action_authorize_member",
-    '6': "handle_action_notifications",
-    'handle_action_notifications': "handle_action_notifications",
-    '7': "handle_action_switch_account",
-    'handle_action_switch_account': "handle_action_switch_account",
-
+    "1": "handle_action_offer_credex",
+    "handle_action_offer_credex": "handle_action_offer_credex",
+    "2": "handle_action_pending_offers_in",
+    "handle_action_pending_offers_in": "handle_action_pending_offers_in",
+    "3": "handle_action_pending_offers_out",
+    "handle_action_pending_offers_out": "handle_action_pending_offers_out",
+    "4": "handle_action_transactions",
+    "handle_action_transactions": "handle_action_transactions",
+    "5": "handle_action_authorize_member",
+    "handle_action_authorize_member": "handle_action_authorize_member",
+    "6": "handle_action_notifications",
+    "handle_action_notifications": "handle_action_notifications",
+    "7": "handle_action_switch_account",
+    "handle_action_switch_account": "handle_action_switch_account",
 }
 
 ABOUT = """
diff --git a/app/core/message_handling/action_handlers.py b/app/core/message_handling/action_handlers.py
index 1a9bad0..a69a4ac 100644
--- a/app/core/message_handling/action_handlers.py
+++ b/app/core/message_handling/action_handlers.py
@@ -18,7 +18,7 @@ from .screens import (
     OFFER_SUCCESSFUL,
     ACCEPT_CREDEX,
     OUTGOING_CREDEX,
-    CREDEX
+    CREDEX,
 )
 from ..utils.utils import wrap_text, get_greeting
 from ..config.constants import *
@@ -27,35 +27,35 @@ from serializers.offers import OfferCredexSerializer
 from core.utils.utils import CredexWhatsappService
 
 
-
-
 class ActionHandler:
 
-    def __init__(self, service: 'CredexBotService'):
+    def __init__(self, service: "CredexBotService"):
         self.service = service
 
     def handle_action_register(self, register=False):
         if register:
             return registration_form(
                 self.service.user.mobile_number,
-                "*Welcome To Credex!*\n\nIt looks like you're new here. Let's get you \nset up."
+                "*Welcome To Credex!*\n\nIt looks like you're new here. Let's get you \nset up.",
             )
 
-        if self.service.message['type'] == "nfm_reply":
+        if self.service.message["type"] == "nfm_reply":
             payload = {
-                "first_name": self.service.body.get('firstName'),
-                "last_name": self.service.body.get('lastName'),
-                "phone_number": self.service.message['from']
+                "first_name": self.service.body.get("firstName"),
+                "last_name": self.service.body.get("lastName"),
+                "phone_number": self.service.message["from"],
             }
             serializer = MemberDetailsSerializer(data=payload)
             if serializer.is_valid():
-                successful, message = self.service.api_interactions.register_member(serializer.validated_data)
+                successful, message = self.service.api_interactions.register_member(
+                    serializer.validated_data
+                )
                 if successful:
                     self.service.state.update_state(
                         self.service.current_state,
                         stage="handle_action_menu",
                         update_from="handle_action_menu",
-                        option="handle_action_menu"
+                        option="handle_action_menu",
                     )
                     return self.handle_action_menu(message=f"\n{message}\n\n")
                 else:
@@ -72,15 +72,15 @@ class ActionHandler:
 
         user = CachedUser(self.service.user.mobile_number)
         current_state = user.state.get_state(user)
-        if not current_state.get('profile') or login:
+        if not current_state.get("profile") or login:
             response = self.service.refresh(reset=True)
             current_state = user.state.get_state(user)
             if response:
                 self.service.state_manager.update_state(
                     new_state=self.service.current_state,
                     update_from="handle_action_menu",
-                    stage='handle_action_register',
-                    option="handle_action_register"
+                    stage="handle_action_register",
+                    option="handle_action_register",
                 )
                 return response
 
@@ -154,47 +154,54 @@ class ActionHandler:
         # }
 
         # Get the member tier & currently selected account to render the menu
-        member_tier = current_state.get('profile', {}).get('memberDashboard', {}).get('memberTier', {}).get('low', 1)
-        selected_account = current_state.get('current_account')
+        member_tier = (
+            current_state.get("profile", {})
+            .get("memberDashboard", {})
+            .get("memberTier", {})
+            .get("low", 1)
+        )
+        selected_account = current_state.get("current_account")
 
         if member_tier >= 2 and not selected_account:
             return self.handle_action_select_profile()
 
         if not selected_account:
-            selected_account = current_state['profile']['memberDashboard']['accounts'][0]
-            current_state['current_account'] = selected_account
+            selected_account = current_state["profile"]["memberDashboard"]["accounts"][
+                0
+            ]
+            current_state["current_account"] = selected_account
             try:
                 user.state.update_state(
                     state=current_state,
-                    stage='handle_action_menu',
+                    stage="handle_action_menu",
                     update_from="handle_action_menu",
-                    option="handle_action_menu"
+                    option="handle_action_menu",
                 )
                 self.service.state_manager.update_state(
                     new_state=current_state,
-                    stage='handle_action_menu',
+                    stage="handle_action_menu",
                     update_from="handle_action_menu",
-                    option="handle_action_menu"
+                    option="handle_action_menu",
                 )
             except Exception as e:
                 print("ERROR : ", e)
 
-        pending = ''
+        pending = ""
         pending_in = 0
-        if selected_account['data']['pendingInData']['data']:
-            pending_in = len(selected_account['data']['pendingInData']['data'])
+        if selected_account["data"]["pendingInData"]["data"]:
+            pending_in = len(selected_account["data"]["pendingInData"]["data"])
             pending = f"    Pending Offers ({pending_in})"
 
         pending_out = 0
-        if selected_account['data']['pendingOutData']['data']:
-            pending_out = len(selected_account['data']['pendingOutData']['data'])
+        if selected_account["data"]["pendingOutData"]["data"]:
+            pending_out = len(selected_account["data"]["pendingOutData"]["data"])
 
         balances = ""
         secured = ""
 
-        balance_data = selected_account['data']['balanceData']['data']
-        is_owned_account = selected_account['data'].get('isOwnedAccount')
-        for bal in balance_data['securedNetBalancesByDenom'] :
+        balance_data = selected_account["data"]["balanceData"]["data"]
+        is_owned_account = selected_account["data"].get("isOwnedAccount")
+        for bal in balance_data["securedNetBalancesByDenom"]:
             balances += f"- {bal}\n"
             secured += f" *{bal}* \n"
 
@@ -207,32 +214,44 @@ class ActionHandler:
                 "type": "list",
                 "body": {
                     "text": (HOME_2 if is_owned_account else HOME_1).format(
-                        message=message if message else '',
-                        account=current_state.get('current_account', {}).get('accountName',
-                                                                                       "Personal Account"),
+                        message=message if message else "",
+                        account=current_state.get("current_account", {}).get(
+                            "accountName", "Personal Account"
+                        ),
                         balance=BALANCE.format(
-                            securedNetBalancesByDenom=balances if balances else "    $0.00\n",
-                            unsecured_balance=UNSERCURED_BALANCES.format(
+                            securedNetBalancesByDenom=(
+                                balances if balances else "    $0.00\n"
+                            ),
+                            unsecured_balance=(
+                                UNSERCURED_BALANCES.format(
                                     totalPayables=balance_data[
-                                    'unsecuredBalancesInDefaultDenom']['totalPayables'],
+                                        "unsecuredBalancesInDefaultDenom"
+                                    ]["totalPayables"],
                                     totalReceivables=balance_data[
-                                    'unsecuredBalancesInDefaultDenom']['totalReceivables'],
+                                        "unsecuredBalancesInDefaultDenom"
+                                    ]["totalReceivables"],
                                     netPayRec=balance_data[
-                                    'unsecuredBalancesInDefaultDenom']['netPayRec'],
-                            ) if member_tier > 2 else f"Free tier remaining daily spend limit\n    *{current_state['profile'].get('remainingAvailableUSD', '0.00')} USD*\n{pending}\n",
+                                        "unsecuredBalancesInDefaultDenom"
+                                    ]["netPayRec"],
+                                )
+                                if member_tier > 2
+                                else f"Free tier remaining daily spend limit\n    *{current_state['profile'].get('remainingAvailableUSD', '0.00')} USD*\n{pending}\n"
+                            ),
                             netCredexAssetsInDefaultDenom=balance_data[
-                                'netCredexAssetsInDefaultDenom']
+                                "netCredexAssetsInDefaultDenom"
+                            ],
                         ),
-                        handle=current_state['current_account']['data']['accountHandle'],
+                        handle=current_state["current_account"]["data"][
+                            "accountHandle"
+                        ],
                     )
                 },
-                "action":
-                    {
+                "action": {
                     "button": "🕹️ Options",
                     "sections": [
                         {
                             "title": "Options",
-                                "rows":
+                            "rows": (
                                 [
                                     {
                                         "id": "handle_action_offer_credex",
@@ -240,28 +259,30 @@ class ActionHandler:
                                     },
                                     {
                                         "id": "handle_action_pending_offers_in",
-                                            "title": f"📥 Pending Offers ({pending_in})"
+                                        "title": f"📥 Pending Offers ({pending_in})",
                                     },
                                     {
                                         "id": "handle_action_pending_offers_out",
-                                            "title": f"📤 Review Outgoing ({pending_out})"
+                                        "title": f"📤 Review Outgoing ({pending_out})",
                                     },
                                     {
                                         "id": "handle_action_transactions",
                                         "title": f"📒 Review Transactions",
-                                        }
-                                    ] if not (is_owned_account and member_tier > 2)  else [
+                                    },
+                                ]
+                                if not (is_owned_account and member_tier > 2)
+                                else [
                                     {
                                         "id": "handle_action_offer_credex",
                                         "title": f"💸 Offer Secured Credex",
                                     },
                                     {
                                         "id": "handle_action_pending_offers_in",
-                                            "title": f"📥 Pending Offers ({pending_in})"
+                                        "title": f"📥 Pending Offers ({pending_in})",
                                     },
                                     {
                                         "id": "handle_action_pending_offers_out",
-                                            "title": f"📤 Review Outgoing ({pending_out})"
+                                        "title": f"📤 Review Outgoing ({pending_out})",
                                     },
                                     {
                                         "id": "handle_action_transactions",
@@ -269,20 +290,22 @@ class ActionHandler:
                                     },
                                     {
                                         "id": "handle_action_authorize_member",
-                                            "title": f"👥 Manage Members"
-                                        }, {
+                                        "title": f"👥 Manage Members",
+                                    },
+                                    {
                                         "id": "handle_action_notifications",
-                                            "title": f"🛎️ Notifications"
+                                        "title": f"🛎️ Notifications",
                                     },
                                     {
                                         "id": "handle_action_switch_account",
                                         "title": f"🏡 Member Dashboard",
-                                        }
-                                    ]
-                            }
+                                    },
                                 ]
+                            ),
                         }
-            }
+                    ],
+                },
+            },
         }
 
     def handle_action_select_profile(self, message=None):
@@ -295,23 +317,29 @@ class ActionHandler:
         user = CachedUser(self.service.user.mobile_number)
         current_state = user.state.get_state(self.service.user)
 
-        if not current_state.get('profile'):
+        if not current_state.get("profile"):
             self.service.api_interactions.refresh_member_info()
             user = CachedUser(self.service.user.mobile_number)
             current_state = user.state.get_state(self.service.user)
 
-
         if user.state.option == "handle_action_display_offers":
-            data = current_state.get('current_account', {}).get('data', {}).get('pendingInData', {}).get('data', [])
-            if self.service.body in [str(i) for i in range(1, len(data) + 1)] or self.service.message[
-                'type'] == 'interactive':
+            data = (
+                current_state.get("current_account", {})
+                .get("data", {})
+                .get("pendingInData", {})
+                .get("data", [])
+            )
+            if (
+                self.service.body in [str(i) for i in range(1, len(data) + 1)]
+                or self.service.message["type"] == "interactive"
+            ):
                 if data:
                     item = None
                     if self.service.body.isdigit():
                         item = data[int(self.service.body) - 1]
                     else:
                         for row in data:
-                            if row.get('credexID') == self.service.body:
+                            if row.get("credexID") == self.service.body:
                                 item = row
                                 break
 
@@ -325,9 +353,13 @@ class ActionHandler:
                                 "type": "button",
                                 "body": {
                                     "text": ACCEPT_CREDEX.format(
-                                        amount=item.get('formattedInitialAmount'),
-                                        party=item.get('counterpartyAccountName'),
-                                        type='Secured' if item.get('secured') else 'Unsecured'
+                                        amount=item.get("formattedInitialAmount"),
+                                        party=item.get("counterpartyAccountName"),
+                                        type=(
+                                            "Secured"
+                                            if item.get("secured")
+                                            else "Unsecured"
+                                        ),
                                     )
                                 },
                                 "action": {
@@ -336,51 +368,55 @@ class ActionHandler:
                                             "type": "reply",
                                             "reply": {
                                                 "id": f"decline_{item.get('credexID')}",
-                                                "title": "❌ Decline"
-                                            }
+                                                "title": "❌ Decline",
+                                            },
                                         },
                                         {
                                             "type": "reply",
                                             "reply": {
                                                 "id": f"accept_{item.get('credexID')}",
-                                                "title": "✅ Accept"
-                                            }
-                                        }
+                                                "title": "✅ Accept",
+                                            },
+                                        },
                                     ]
-                                }
-                            }
+                                },
+                            },
                         }
 
-        if self.service.body == 'handle_action_pending_offers_in':
+        if self.service.body == "handle_action_pending_offers_in":
             rows = []
             menu_string = "> *📥 Pending Incoming*\n"
-            data = current_state.get('current_account', {}).get('data', {}).get('pendingInData', {}).get('data', [])
+            data = (
+                current_state.get("current_account", {})
+                .get("data", {})
+                .get("pendingInData", {})
+                .get("data", [])
+            )
             for count, item in enumerate(data[:10], start=1):
                 menu_string += f"\n{count}. *Total Credex Amount :* {item.get('formattedInitialAmount')}\n        *From :* {item.get('counterpartyAccountName')}\n"
                 rows.append(
                     {
-                        "id": item.get('credexID'),
+                        "id": item.get("credexID"),
                         "title": f"{item.get('formattedInitialAmount')}",
-                        "description": f"from {item.get('counterpartyAccountName')}"
+                        "description": f"from {item.get('counterpartyAccountName')}",
                     }
                 )
 
             user.state.update_state(
                 state=current_state,
-                stage='handle_action_pending_offers_in',
+                stage="handle_action_pending_offers_in",
                 update_from="handle_action_pending_offers_in",
-                option="handle_action_display_offers"
+                option="handle_action_display_offers",
             )
 
             if not rows:
                 menu_string = "*Empty*\n\n🪹 No pending offers to display!\n\n"
-                rows = [
-                    {
-                        "id": "X",
-                        "title": "🏡 Menu"
-                    }
-                ]
-                return wrap_text(user_mobile_number=self.service.user.mobile_number , message=menu_string, extra_rows=rows)
+                rows = [{"id": "X", "title": "🏡 Menu"}]
+                return wrap_text(
+                    user_mobile_number=self.service.user.mobile_number,
+                    message=menu_string,
+                    extra_rows=rows,
+                )
 
             return {
                 "messaging_product": "whatsapp",
@@ -389,9 +425,7 @@ class ActionHandler:
                 "type": "interactive",
                 "interactive": {
                     "type": "list",
-                    "body": {
-                        "text": menu_string
-                    },
+                    "body": {"text": menu_string},
                     "action": {
                         "button": "✅ Accept All",
                         "sections": [
@@ -400,16 +434,16 @@ class ActionHandler:
                                 "rows": [
                                     {
                                         "id": "AcceptAllIncomingOffers",
-                                        "title": "✅ Accept All"
-                                    }
-                                ]
-                            }
-                        ]
+                                        "title": "✅ Accept All",
                                     }
+                                ],
                             }
+                        ],
+                    },
+                },
             }
         else:
-            if self.service.body == 'AcceptAllIncomingOffers':
+            if self.service.body == "AcceptAllIncomingOffers":
                 return self.handle_action_accept_all_incoming_offers()
 
     def handle_action_accept_offer(self):
@@ -420,39 +454,42 @@ class ActionHandler:
 
         payload = {
             "credexID": self.service.body.split("_")[-1],
-            "signerID": current_state['profile']['member'].get('memberID')
+            "signerID": current_state["profile"]["member"].get("memberID"),
         }
         successful, message = self.service.api_interactions.accept_credex(payload)
 
-
         if successful:
             secured = ""
-            for item in message['data']['dashboard']['data']['balanceData']['data']['securedNetBalancesByDenom']:
+            for item in message["data"]["dashboard"]["data"]["balanceData"]["data"][
+                "securedNetBalancesByDenom"
+            ]:
                 secured += f" *{item}* \n"
 
             balances = ""
-            balance_lists = message['data']['dashboard']['data']['balanceData']['data'][
-                'unsecuredBalancesInDefaultDenom']
+            balance_lists = message["data"]["dashboard"]["data"]["balanceData"]["data"][
+                "unsecuredBalancesInDefaultDenom"
+            ]
             for bal in balance_lists.keys():
                 balances += f"- {bal} {balance_lists[bal]}\n"
 
             message = BALANCE.format(
                 securedNetBalancesByDenom=secured if secured else "    $0.00\n",
                 unsecured_balance=balances,
-                netCredexAssetsInDefaultDenom=message['data']['dashboard']['data']['balanceData']['data'][
-                    'netCredexAssetsInDefaultDenom']
+                netCredexAssetsInDefaultDenom=message["data"]["dashboard"]["data"][
+                    "balanceData"
+                ]["data"]["netCredexAssetsInDefaultDenom"],
             )
 
             return wrap_text(
                 message=f"> 💸 *SUCCESS* \n\n{message}\n*Successfully Accepted Credex*\n",
                 user_mobile_number=self.service.user.mobile_number,
-                extra_rows=[]
+                extra_rows=[],
             )
         else:
             return wrap_text(
                 message=message,
                 user_mobile_number=self.service.user.mobile_number,
-                extra_rows=[]
+                extra_rows=[],
             )
 
     def handle_action_decline_offer(self):
@@ -465,20 +502,20 @@ class ActionHandler:
 
         payload = {
             "credexID": self.service.body.split("_")[-1],
-            "signerID":current_state['profile']['member'].get('memberID')
+            "signerID": current_state["profile"]["member"].get("memberID"),
         }
         successful, _ = self.service.api_interactions.decline_credex(payload)
         if successful:
             return wrap_text(
                 message="*Offer declined successfully*",
                 user_mobile_number=self.service.user.mobile_number,
-                extra_rows=[]
+                extra_rows=[],
             )
         else:
             return wrap_text(
                 message="*Failed to decline offer*",
                 user_mobile_number=self.service.user.mobile_number,
-                extra_rows=[]
+                extra_rows=[],
             )
 
     def handle_action_cancel_offer(self):
@@ -491,20 +528,20 @@ class ActionHandler:
 
         payload = {
             "credexID": self.service.body.split("_")[-1],
-            "signerID": current_state['profile']['member'].get('memberID')
+            "signerID": current_state["profile"]["member"].get("memberID"),
         }
         successful, _ = self.service.api_interactions.cancel_credex(payload)
         if successful:
             return wrap_text(
                 message="> *Cancelled by issuer*\n\n*Credex has been cancelled successfully*",
                 user_mobile_number=self.service.user.mobile_number,
-                extra_rows=[]
+                extra_rows=[],
             )
         else:
             return wrap_text(
                 message="*Credex could not be cancelled*",
                 user_mobile_number=self.service.user.mobile_number,
-                extra_rows=[]
+                extra_rows=[],
             )
 
     def handle_action_accept_all_incoming_offers(self):
@@ -512,44 +549,54 @@ class ActionHandler:
         user = CachedUser(self.service.user.mobile_number)
         current_state = user.state.get_state(self.service.user)
 
-        data = current_state.get('current_account', {}).get('pendingInData') if current_state.get('current_account', {}).get('pendingInData') else []
+        data = (
+            current_state.get("current_account", {}).get("pendingInData")
+            if current_state.get("current_account", {}).get("pendingInData")
+            else []
+        )
         payload = {
-            "signerID": current_state['profile']['member'].get('memberID'),
-            "credexIDs": [i.get('credexID') for i in data]
+            "signerID": current_state["profile"]["member"].get("memberID"),
+            "credexIDs": [i.get("credexID") for i in data],
         }
         status, message = self.service.api_interactions.accept_bulk_credex(payload)
         if status:
             secured = ""
-            for item in message['dashboardData']['balanceData']['securedNetBalancesByDenom']:
+            for item in message["dashboardData"]["balanceData"][
+                "securedNetBalancesByDenom"
+            ]:
                 secured += f" *{item}* \n"
 
             balances = ""
-            balance_lists = message['dashboardData']['balanceData']['securedNetBalancesByDenom']
+            balance_lists = message["dashboardData"]["balanceData"][
+                "securedNetBalancesByDenom"
+            ]
             for bal in balance_lists:
                 balances += f"- {bal}\n"
 
             message = BALANCE.format(
                 securedNetBalancesByDenom=balances if balances else "    $0.00\n",
                 unsecured_balance="",
-                netCredexAssetsInDefaultDenom=message['dashboardData']['balanceData']['netCredexAssetsInDefaultDenom']
+                netCredexAssetsInDefaultDenom=message["dashboardData"]["balanceData"][
+                    "netCredexAssetsInDefaultDenom"
+                ],
             )
 
             user.state.update_state(
                 state=current_state,
-                stage='handle_action_menu',
+                stage="handle_action_menu",
                 update_from="handle_action_accept_all_incoming_offers",
-                option="handle_action_menu"
+                option="handle_action_menu",
             )
             return wrap_text(
                 message=f"> 💸 *SUCCESS* \n\n{message}\n *All offers accepted successfully*",
                 user_mobile_number=self.service.user.mobile_number,
-                x_is_menu=True
+                x_is_menu=True,
             )
         else:
             return wrap_text(
                 message="*Failed to accept all offers*",
                 user_mobile_number=self.service.user.mobile_number,
-                x_is_menu=True
+                x_is_menu=True,
             )
 
     def handle_action_pending_offers_out(self):
@@ -678,9 +725,17 @@ class ActionHandler:
         #     "message": "Dashboard retrieved successfully"
         # }
         if user.state.option == "handle_action_display_offers":
-            data = current_state.get('current_account', {}).get('data', {}).get('pendingOutData', {}).get('data', [])
+            data = (
+                current_state.get("current_account", {})
+                .get("data", {})
+                .get("pendingOutData", {})
+                .get("data", [])
+            )
             print("DATA ", data)
-            if self.service.body  in [str(i) for i in range(1, len(data) + 1)] or self.service.message['type'] == 'interactive':
+            if (
+                self.service.body in [str(i) for i in range(1, len(data) + 1)]
+                or self.service.message["type"] == "interactive"
+            ):
                 print("DATA : ", data)
                 if data:
                     item = None
@@ -689,7 +744,7 @@ class ActionHandler:
                     else:
                         for row in data:
                             print("ROW : ", row)
-                            if row.get('credexID') == self.service.body:
+                            if row.get("credexID") == self.service.body:
                                 item = row
                                 break
                     return {
@@ -701,9 +756,13 @@ class ActionHandler:
                             "type": "button",
                             "body": {
                                 "text": OUTGOING_CREDEX.format(
-                                    amount=item.get('formattedInitialAmount'),
-                                    party=item.get('counterpartyAccountName'),
-                                    type='Secured' if item.get('secured') else 'Unsecured'
+                                    amount=item.get("formattedInitialAmount"),
+                                    party=item.get("counterpartyAccountName"),
+                                    type=(
+                                        "Secured"
+                                        if item.get("secured")
+                                        else "Unsecured"
+                                    ),
                                 )
                             },
                             "action": {
@@ -712,37 +771,42 @@ class ActionHandler:
                                         "type": "reply",
                                         "reply": {
                                             "id": f"cancel_{item.get('credexID')}",
-                                            "title": "❌ Cancel"
-                                        }
+                                            "title": "❌ Cancel",
+                                        },
                                     }
                                 ]
-                            }
-                        }
+                            },
+                        },
                     }
 
-        if self.service.body == 'handle_action_pending_offers_out':
+        if self.service.body == "handle_action_pending_offers_out":
             rows = []
             menu_string = "> *📤 Pending Outgoing*\n\n*Offers*\n"
             count = 1
-            current_state.get('current_account', {}).get('pendingOutData')
-            data = current_state.get('current_account', {}).get('data', {}).get('pendingOutData', {}).get('data', [])
+            current_state.get("current_account", {}).get("pendingOutData")
+            data = (
+                current_state.get("current_account", {})
+                .get("data", {})
+                .get("pendingOutData", {})
+                .get("data", [])
+            )
             for item in data[:10]:
-                counterparty = item.get('counterpartyAccountName')
+                counterparty = item.get("counterpartyAccountName")
                 menu_string += f"{count}. *{item.get('formattedInitialAmount')}* outgoing offer sent to\n        {counterparty}\n"
                 rows.append(
                     {
-                        "id": item.get('credexID'),
+                        "id": item.get("credexID"),
                         "title": f"{item.get('formattedInitialAmount')}",
-                        "description": f"to {item.get('counterpartyAccountName')}"
+                        "description": f"to {item.get('counterpartyAccountName')}",
                     }
                 )
                 count += 1
 
             user.state.update_state(
                 state=current_state,
-                stage='handle_action_pending_offers_out',
+                stage="handle_action_pending_offers_out",
                 update_from="handle_action_pending_offers_out",
-                option="handle_action_display_offers"
+                option="handle_action_display_offers",
             )
 
             if not rows:
@@ -750,7 +814,7 @@ class ActionHandler:
                 return wrap_text(
                     message=menu_string,
                     user_mobile_number=self.service.user.mobile_number,
-                    x_is_menu=True
+                    x_is_menu=True,
                 )
 
             return {
@@ -760,19 +824,12 @@ class ActionHandler:
                 "type": "interactive",
                 "interactive": {
                     "type": "list",
-                    "body": {
-                        "text": menu_string
-                    },
+                    "body": {"text": menu_string},
                     "action": {
                         "button": "🕹️ Options",
-                        "sections": [
-                            {
-                                "title": "Options",
-                                "rows": rows
-                            }
-                        ]
-                    }
-                }
+                        "sections": [{"title": "Options", "rows": rows}],
+                    },
+                },
             }
 
     def handle_action_transactions(self):
@@ -780,21 +837,26 @@ class ActionHandler:
         user = CachedUser(self.service.user.mobile_number)
         current_state = user.state.get_state(self.service.user)
 
+        page_number = current_state.get("page_number", 0)
 
-        page_number = current_state.get('page_number', 0)
-
-        if self.service.body in ['Next', 'next', 'handle_action_transactions']:
+        if self.service.body in ["Next", "next", "handle_action_transactions"]:
             page_number += 1
-        elif self.service.body in ['Prev', 'prev'] and page_number > 1:
+        elif self.service.body in ["Prev", "prev"] and page_number > 1:
             page_number -= 1
         else:
             if self.service.body.isdigit():
-                if 0 < int(self.service.body) <= len(current_state.get('current_page', [])):
-                    self.service.body = current_state['current_page'][int(self.service.body) - 1]['id']
+                if (
+                    0
+                    < int(self.service.body)
+                    <= len(current_state.get("current_page", []))
+                ):
+                    self.service.body = current_state["current_page"][
+                        int(self.service.body) - 1
+                    ]["id"]
 
             payload = {
                 "credexID": self.service.body,
-                "accountID": current_state['profile']['member'].get('memberID'),
+                "accountID": current_state["profile"]["member"].get("memberID"),
             }
 
             done, response = self.service.api_interactions.get_credex(payload)
@@ -810,47 +872,49 @@ class ActionHandler:
                             "type": "list",
                             "body": {
                                 "text": CREDEX.format(
-                                    formattedOutstandingAmount=credex['credexData'].get('formattedOutstandingAmount'),
-                                    formattedInitialAmount=credex['credexData'].get('formattedInitialAmount'),
-                                    counterpartyDisplayname=credex['credexData'].get('counterpartyAccountName'),
-                                    date=credex['credexData'].get('dateTime') if credex['credexData'].get(
-                                        'dateTime') else 'N/A',
-                                    type=credex['credexData'].get('transactionType')
+                                    formattedOutstandingAmount=credex["credexData"].get(
+                                        "formattedOutstandingAmount"
+                                    ),
+                                    formattedInitialAmount=credex["credexData"].get(
+                                        "formattedInitialAmount"
+                                    ),
+                                    counterpartyDisplayname=credex["credexData"].get(
+                                        "counterpartyAccountName"
+                                    ),
+                                    date=(
+                                        credex["credexData"].get("dateTime")
+                                        if credex["credexData"].get("dateTime")
+                                        else "N/A"
+                                    ),
+                                    type=credex["credexData"].get("transactionType"),
                                 )
                             },
-                            "action":
-                                {
+                            "action": {
                                 "button": "🕹️ Menu",
                                 "sections": [
                                     {
                                         "title": "Options",
-                                            "rows": [
-                                                {
-                                                    "id": "X",
-                                                    "title": "🏡 Menu"
-                                                }
-                                            ]
-                                        }
-                                    ]
-                                }
+                                        "rows": [{"id": "X", "title": "🏡 Menu"}],
                                     }
+                                ],
+                            },
+                        },
                     }
 
             menu_string = "*Empty*\n\n🪹 No transaction(s) found!\n\n"
             return wrap_text(
                 message=menu_string,
                 user_mobile_number=self.service.user.mobile_number,
-                x_is_menu=True
+                x_is_menu=True,
             )
         print(">>>>>>", page_number)
 
         payload = {
-            "accountID": current_state['current_account'].get('accountID'),
+            "accountID": current_state["current_account"].get("accountID"),
             "numRows": 8,
-            "startRow": (page_number * 7) - 7 if (page_number * 7) - 7  > 0 else 1
+            "startRow": (page_number * 7) - 7 if (page_number * 7) - 7 > 0 else 1,
         }
 
-
         done, transactions = self.service.api_interactions.get_ledger(payload)
         if done:
             has_next = True if len(transactions) > 7 else False
@@ -858,43 +922,33 @@ class ActionHandler:
             menu_string = f"> *💳 TRANSACTIONS*\n\n*PAGE #{page_number}*\n\n"
             count = 1
             for txn in transactions:
-                if 'Next' in txn.get('formattedInitialAmount'):
+                if "Next" in txn.get("formattedInitialAmount"):
                     continue
                 # if count > 8:
                 #     break
                 nl = "\n"
                 menu_string += f"*{count}.* *{txn.get('formattedInitialAmount')}* {'to ' if '-' in txn.get('formattedInitialAmount') else 'from '}{txn.get('counterpartyAccountName').replace('Personal', f'{nl}     Personal')}\n\n"
-                rows.append({
-                    "id": txn.get('credexID'),
+                rows.append(
+                    {
+                        "id": txn.get("credexID"),
                         "title": f"{txn.get('formattedInitialAmount').replace('-', '')} {'DEBIT ' if '-' in txn.get('formattedInitialAmount') else 'CREDIT '}",
-                    "description": f"{txn.get('formattedInitialAmount')} {'to ' if '-' in txn.get('formattedInitialAmount') else 'from '}{txn.get('counterpartyAccountName')}"
-                })
+                        "description": f"{txn.get('formattedInitialAmount')} {'to ' if '-' in txn.get('formattedInitialAmount') else 'from '}{txn.get('counterpartyAccountName')}",
+                    }
+                )
                 count += 1
-            current_state['page_number'] = page_number
-            current_state['current_page'] = rows
+            current_state["page_number"] = page_number
+            current_state["current_page"] = rows
             user.state.update_state(
                 state=current_state,
-                stage='handle_action_transactions',
+                stage="handle_action_transactions",
                 update_from="handle_action_transactions",
-                option="handle_action_transactions"
+                option="handle_action_transactions",
             )
             if page_number > 1:
-                rows.append(
-                    {
-                        "id": "Prev",
-                        "title": "< Prev",
-                        "description": "< Prev"
-                    }
-                )
+                rows.append({"id": "Prev", "title": "< Prev", "description": "< Prev"})
 
             if has_next:
-                rows.append(
-                    {
-                        "id": "Next",
-                        "title": "Next >",
-                        "description": "Next >"
-                    }
-                )
+                rows.append({"id": "Next", "title": "Next >", "description": "Next >"})
 
             print(len(rows))
 
@@ -909,31 +963,25 @@ class ActionHandler:
                         "body": {
                             "text": menu_string + f"Send *'Menu'* to go back to Menu"
                         },
-                        "action":
-                            {
+                        "action": {
                             "button": "🕹️ Options",
-                                "sections": [
-                                    {
-                                        "title": "Options",
-                                        "rows": rows
-                                    }
-                                ]
-                            }
-                    }
+                            "sections": [{"title": "Options", "rows": rows}],
+                        },
+                    },
                 }
             menu_string = "*Empty*\n\n🪹 No transactions found!\n\n"
 
             return wrap_text(
                 message=menu_string,
                 user_mobile_number=self.service.user.mobile_number,
-                x_is_menu=True
+                x_is_menu=True,
             )
         else:
             menu_string = "*Empty*\n\n🪹 No transactions found!\n\n"
             return wrap_text(
                 message=menu_string,
                 user_mobile_number=self.service.user.mobile_number,
-                x_is_menu=True
+                x_is_menu=True,
             )
 
     def handle_action_create_business_account(self):
@@ -1024,161 +1072,209 @@ class ActionHandler:
         current_state = user.state.get_state(self.service.user)
 
         # Get the selected profile
-        selected_profile = current_state.get('current_account', {})
+        selected_profile = current_state.get("current_account", {})
 
         # Get the member dashboard
-        member_dashboard = current_state.get('memberDashboard', {})
+        member_dashboard = current_state.get("memberDashboard", {})
 
-        message = ''
-        if not current_state.get('profile'):
+        message = ""
+        if not current_state.get("profile"):
             # Refresh the user state
             response = self.service.api_interactions.refresh_member_info()
             if response:
                 self.service.state_manager.update_state(
                     new_state=self.service.current_state,
                     update_from="handle_action_offer_credex",
-                    stage='handle_action_register',
-                    option="handle_action_register"
+                    stage="handle_action_register",
+                    option="handle_action_register",
                 )
                 return response
 
-        member_tier = current_state.get('member', {}).get('memberDashboard', {}).get('memberTier', {}).get('low', 1)
+        member_tier = (
+            current_state.get("member", {})
+            .get("memberDashboard", {})
+            .get("memberTier", {})
+            .get("low", 1)
+        )
 
-        if not current_state.get('current_account', {}) and member_tier >= 2:
+        if not current_state.get("current_account", {}) and member_tier >= 2:
             # Select a default profile
             return self.handle_action_select_profile()
         else:
             if not selected_profile:
-                selected_profile = current_state['profile']['memberDashboard']['accounts'][0]
-                current_state['current_account'] = selected_profile
+                selected_profile = current_state["profile"]["memberDashboard"][
+                    "accounts"
+                ][0]
+                current_state["current_account"] = selected_profile
                 self.service.state_manager.update_state(
                     new_state=current_state,
-                    stage='handle_action_offer_credex',
+                    stage="handle_action_offer_credex",
                     update_from="handle_action_offer_credex",
-                    option="handle_action_offer_credex"
+                    option="handle_action_offer_credex",
                 )
 
         payload = {}
-        if "=>" in f"{self.service.body}" or "->" f"{self.service.body}" or self.service.message['type'] == "nfm_reply":
-            if self.service.message['type'] == "nfm_reply":
+        if (
+            "=>" in f"{self.service.body}"
+            or "->" f"{self.service.body}"
+            or self.service.message["type"] == "nfm_reply"
+        ):
+            if self.service.message["type"] == "nfm_reply":
                 from datetime import datetime, timedelta
+
                 payload = {
-                    "authorizer_member_id": current_state['profile'].get('member', {}).get('memberID'),
-                    "issuer_member_id": selected_profile['data']['accountID'],
-                    "handle": self.service.body.get('handle'),
-                    "amount": self.service.body.get('amount'),
-                    "dueDate": self.service.body.get(
-                        'due_date'
-                    ) if self.service.body.get('due_date') else (
-                        datetime.now() + timedelta(weeks=4)
-                    ).timestamp() * 1000,
-                    "currency": self.service.body.get('currency'),
-                    "securedCredex": True
+                    "authorizer_member_id": current_state["profile"]
+                    .get("member", {})
+                    .get("memberID"),
+                    "issuer_member_id": selected_profile["data"]["accountID"],
+                    "handle": self.service.body.get("handle"),
+                    "amount": self.service.body.get("amount"),
+                    "dueDate": (
+                        self.service.body.get("due_date")
+                        if self.service.body.get("due_date")
+                        else (datetime.now() + timedelta(weeks=4)).timestamp() * 1000
+                    ),
+                    "currency": self.service.body.get("currency"),
+                    "securedCredex": True,
                 }
 
             if "=>" in f"{self.service.body}" or "->" f"{self.service.body}":
                 if "=>" in f"{self.service.body}":
-                    amount, user = f"{self.service.body}".split('=>')
+                    amount, user = f"{self.service.body}".split("=>")
                     if "=" in user:
                         user, _ = user.split("=")
                     from datetime import datetime
+
                     payload = {
-                        "authorizer_member_id": current_state['profile']['member'].get('memberID'),
-                        "issuer_member_id": selected_profile['data']['accountID'],
+                        "authorizer_member_id": current_state["profile"]["member"].get(
+                            "memberID"
+                        ),
+                        "issuer_member_id": selected_profile["data"]["accountID"],
                         "handle": user,
                         "amount": amount,
                         "dueDate": (datetime.now()).timestamp() * 1000,
-                        "currency": selected_profile['defaultDenom'] if selected_profile else current_state['profile'].get('member', {}).get('defaultDenom'),
-                        "securedCredex": True
+                        "currency": (
+                            selected_profile["defaultDenom"]
+                            if selected_profile
+                            else current_state["profile"]
+                            .get("member", {})
+                            .get("defaultDenom")
+                        ),
+                        "securedCredex": True,
                     }
 
             if "->" in f"{self.service.body}":
-                if '=' in f"{self.service.body}":
-                    amount, user_date = f"{self.service.body}".split('->')
-                    user, date = user_date.split('=')
+                if "=" in f"{self.service.body}":
+                    amount, user_date = f"{self.service.body}".split("->")
+                    user, date = user_date.split("=")
 
                     try:
                         from datetime import datetime
+
                         # Try to parse the date string with the specified format
-                        datetime.strptime(date, '%Y-%m-%d')
+                        datetime.strptime(date, "%Y-%m-%d")
 
                     except ValueError:
                         # If a ValueError is raised, the date string is not in the correct format
-                        return self.wrap_text(OFFER_CREDEX.format(message='*Invalid Due Date❗*'), x_is_menu=True)
+                        return self.wrap_text(
+                            OFFER_CREDEX.format(message="*Invalid Due Date❗*"),
+                            x_is_menu=True,
+                        )
                 else:
-                    amount, user = f"{self.service.body}".split('->')
+                    amount, user = f"{self.service.body}".split("->")
                     date = None
 
                 from datetime import datetime, timedelta
+
                 payload = {
-                    "authorizer_member_id": current_state['profile'].get('member', {}).get('memberID'),
-                    "issuer_member_id": selected_profile['data']['accountID'],
+                    "authorizer_member_id": current_state["profile"]
+                    .get("member", {})
+                    .get("memberID"),
+                    "issuer_member_id": selected_profile["data"]["accountID"],
                     "handle": user,
                     "amount": amount,
-                    "dueDate": datetime.strptime(
-                        date,
-                        '%Y-%m-%d'
-                        ).timestamp() * 1000 if date else (
-                        datetime.now() + timedelta(weeks=4)).timestamp() * 1000,
-                    "currency": selected_profile['data']['defaultDenom'] if selected_profile else current_state['profile'].get('member', {}).get('defaultDenom'),
-                    "securedCredex": False
+                    "dueDate": (
+                        datetime.strptime(date, "%Y-%m-%d").timestamp() * 1000
+                        if date
+                        else (datetime.now() + timedelta(weeks=4)).timestamp() * 1000
+                    ),
+                    "currency": (
+                        selected_profile["data"]["defaultDenom"]
+                        if selected_profile
+                        else current_state["profile"]
+                        .get("member", {})
+                        .get("defaultDenom")
+                    ),
+                    "securedCredex": False,
                 }
 
-            serializer = OfferCredexSerializer(data=payload, context={"api_interactions": self.service.api_interactions})
+            serializer = OfferCredexSerializer(
+                data=payload,
+                context={"api_interactions": self.service.api_interactions},
+            )
             if serializer.is_valid():
                 accounts = []
                 available_accounts = []
                 count = 1
                 account_string = f""
-                print("PASSED VALIDATION : ", current_state['profile']['memberDashboard']['accounts'])
-                for account in current_state['profile']['memberDashboard']['accounts']:
+                print(
+                    "PASSED VALIDATION : ",
+                    current_state["profile"]["memberDashboard"]["accounts"],
+                )
+                for account in current_state["profile"]["memberDashboard"]["accounts"]:
                     print("ACCOUNT : ", account)
-                    account = account.get('data', {})
-                    if account.get('accountID') not in available_accounts:
+                    account = account.get("data", {})
+                    if account.get("accountID") not in available_accounts:
 
-                        account_string += f" *{count}.*  _{account.get('accountName')}_\n"
+                        account_string += (
+                            f" *{count}.*  _{account.get('accountName')}_\n"
+                        )
                         accounts.append(
                             {
-                                "id": account.get('accountID'),
-                                "title": f"👤{account.get('accountName')}"
+                                "id": account.get("accountID"),
+                                "title": f"👤{account.get('accountName')}",
                             }
                         )
-                        available_accounts.append(account.get('accountID'))
+                        available_accounts.append(account.get("accountID"))
 
                         if count > 8:
                             break
                         count += 1
 
-
                 count += 1
-                response = CONFIRM_SECURED_CREDEX.format(
-                    party=serializer.validated_data.get('full_name'),
-                    amount=serializer.validated_data.get('InitialAmount'),
-                    currency=serializer.validated_data.get('Denomination'),
-                    source=selected_profile.get('accountName'),
-                    handle=serializer.validated_data.pop('handle'),
-                    secured='*secured*',
-                    accounts=account_string
-
-                ) if serializer.validated_data.get('securedCredex') else CONFIRM_UNSECURED_CREDEX.format(
-                    party=serializer.validated_data.get('full_name'),
-                    amount=serializer.validated_data.get('InitialAmount'),
-                    currency=serializer.validated_data.get('Denomination'),
-                    source=selected_profile.get('accountName'),
-                    handle=serializer.validated_data.pop('handle'),
-                    secured='*unsecured*',
+                response = (
+                    CONFIRM_SECURED_CREDEX.format(
+                        party=serializer.validated_data.get("full_name"),
+                        amount=serializer.validated_data.get("InitialAmount"),
+                        currency=serializer.validated_data.get("Denomination"),
+                        source=selected_profile.get("accountName"),
+                        handle=serializer.validated_data.pop("handle"),
+                        secured="*secured*",
+                        accounts=account_string,
+                    )
+                    if serializer.validated_data.get("securedCredex")
+                    else CONFIRM_UNSECURED_CREDEX.format(
+                        party=serializer.validated_data.get("full_name"),
+                        amount=serializer.validated_data.get("InitialAmount"),
+                        currency=serializer.validated_data.get("Denomination"),
+                        source=selected_profile.get("accountName"),
+                        handle=serializer.validated_data.pop("handle"),
+                        secured="*unsecured*",
                         date=f"*Due Date :* {serializer.validated_data.get('dueDate')}",
-                    accounts=account_string
+                        accounts=account_string,
+                    )
                 )
 
                 print("RESPONSE : ", response)
-                current_state['confirm_offer_payload'] = serializer.validated_data
-                current_state['confirm_offer_payload']['secured'] = serializer.validated_data['securedCredex']
+                current_state["confirm_offer_payload"] = serializer.validated_data
+                current_state["confirm_offer_payload"]["secured"] = (
+                    serializer.validated_data["securedCredex"]
+                )
                 self.service.state_manager.update_state(
                     new_state=current_state,
-                    stage='handle_action_offer_credex',
+                    stage="handle_action_offer_credex",
                     update_from="handle_action_offer_credex",
-                    option="handle_action_confirm_offer_credex"
+                    option="handle_action_confirm_offer_credex",
                 )
 
                 return {
@@ -1188,9 +1284,7 @@ class ActionHandler:
                     "type": "interactive",
                     "interactive": {
                         "type": "flow",
-                        "body": {
-                            "text": response
-                        },
+                        "body": {"text": response},
                         "action": {
                             "name": "flow",
                             "parameters": {
@@ -1201,33 +1295,32 @@ class ActionHandler:
                                 "flow_cta": "Sign & Send",
                                 "flow_action_payload": {
                                     "screen": "OFFER_SECURED_CREDEX",
-                                    "data": {
-                                        "source_account": accounts
-                                    }
-                                }
-                            }
-                        }
-                    }
-
+                                    "data": {"source_account": accounts},
+                                },
+                            },
+                        },
+                    },
                 }
             else:
                 print("ERROR : ", serializer.errors)
                 for err in serializer.errors.keys():
                     if "This field is required." != serializer.errors[err][0]:
-                        message = f'*{serializer.errors[err][0]}❗*'
+                        message = f"*{serializer.errors[err][0]}❗*"
                         break
 
         if user.state.option == "handle_action_confirm_offer_credex":
-            to_credex = current_state.get('confirm_offer_payload')
-            to_credex['issuerAccountID'] = selected_profile.get('accountID')
-            if self.service.message['type'] == "nfm_reply":
-                to_credex['issuerAccountID'] = self.service.message['message']['source_account']
+            to_credex = current_state.get("confirm_offer_payload")
+            to_credex["issuerAccountID"] = selected_profile.get("accountID")
+            if self.service.message["type"] == "nfm_reply":
+                to_credex["issuerAccountID"] = self.service.message["message"][
+                    "source_account"
+                ]
 
-            to_credex['memberID'] = member_dashboard.get('memberID')
+            to_credex["memberID"] = member_dashboard.get("memberID")
             to_credex.pop("handle", None)
-            if to_credex.get('securedCredex'):
-                to_credex.pop('dueDate', None)
-            to_credex.pop('secured', None)
+            if to_credex.get("securedCredex"):
+                to_credex.pop("dueDate", None)
+            to_credex.pop("secured", None)
 
             success, message = self.service.api_interactions.offer_credex(to_credex)
             # {
@@ -1326,61 +1419,78 @@ class ActionHandler:
             # }
             print(">>>>> ", message)
             if success:
-                if message['data'].get('action', {}).get('type') == 'CREDEX_CREATED':
+                if message["data"].get("action", {}).get("type") == "CREDEX_CREATED":
 
-                    response = message['data'].get("action", {}).get("details", {})
-                    current_state.pop('confirm_offer_payload', {})
-                    denomination = response.get('denomination', 'USD')
-                    current_state.pop('current_account', {})
+                    response = message["data"].get("action", {}).get("details", {})
+                    current_state.pop("confirm_offer_payload", {})
+                    denomination = response.get("denomination", "USD")
+                    current_state.pop("current_account", {})
 
                     success_message = OFFER_SUCCESSFUL.format(
-                        type='Secured Credex' if response.get('securedCredex') else 'Unsecured Credex',
-                        amount=response.get('amount'),
+                        type=(
+                            "Secured Credex"
+                            if response.get("securedCredex")
+                            else "Unsecured Credex"
+                        ),
+                        amount=response.get("amount"),
                         currency=denomination,
-                        recipient=response.get('receiverAccountName'),
-                        source=selected_profile['data']['accountName'],
-                        secured='*Secured* credex' if response.get('securedCredex') else '*Unsecured* credex',
+                        recipient=response.get("receiverAccountName"),
+                        source=selected_profile["data"]["accountName"],
+                        secured=(
+                            "*Secured* credex"
+                            if response.get("securedCredex")
+                            else "*Unsecured* credex"
+                        ),
                     )
 
                     secured = ""
-                    for item in message['data']['dashboard']['data']['balanceData']['data']['securedNetBalancesByDenom']:
+                    for item in message["data"]["dashboard"]["data"]["balanceData"][
+                        "data"
+                    ]["securedNetBalancesByDenom"]:
                         secured += f" *{item}* \n"
 
                     balances = ""
-                    balance_lists = message['data']['dashboard']['data']['balanceData']['data']['unsecuredBalancesInDefaultDenom']
+                    balance_lists = message["data"]["dashboard"]["data"]["balanceData"][
+                        "data"
+                    ]["unsecuredBalancesInDefaultDenom"]
                     for bal in balance_lists.keys():
                         balances += f"- {bal} {balance_lists[bal]}\n"
 
                     balance_data = BALANCE.format(
                         securedNetBalancesByDenom=secured if secured else "    $0.00\n",
                         unsecured_balance=balances,
-                        netCredexAssetsInDefaultDenom=message['data']['dashboard']['data']['balanceData']['data']['netCredexAssetsInDefaultDenom']
+                        netCredexAssetsInDefaultDenom=message["data"]["dashboard"][
+                            "data"
+                        ]["balanceData"]["data"]["netCredexAssetsInDefaultDenom"],
                     )
 
                     return wrap_text(
                         message=f"{success_message}{balance_data}",
                         user_mobile_number=self.service.user.mobile_number,
-                        x_is_menu=True
+                        x_is_menu=True,
                     )
                 else:
-                    current_state.pop('confirm_offer_payload', {})
+                    current_state.pop("confirm_offer_payload", {})
                     message = self.format_synopsis(
-                        message.get("error", {}).replace("Error:", ""))
+                        message.get("error", {}).replace("Error:", "")
+                    )
             else:
                 try:
-                    current_state.pop('confirm_offer_payload', {})
+                    current_state.pop("confirm_offer_payload", {})
                     message = self.format_synopsis(message.replace("Error:", ""))
                 except Exception as e:
-                    message = 'Invalid option selected'
+                    message = "Invalid option selected"
                     print("ERROR : ", e)
 
         self.service.state_manager.update_state(
             new_state=current_state,
-            stage='handle_action_offer_credex',
+            stage="handle_action_offer_credex",
             update_from="handle_action_offer_credex",
-            option="handle_action_offer_credex"
+            option="handle_action_offer_credex",
+        )
+        return offer_credex(
+            self.service.user.mobile_number, message=self.format_synopsis(message)
         )
-        return offer_credex(self.service.user.mobile_number, message=self.format_synopsis(message))
 
     def handle_default_action(self):
         # Implementation for handling default or unknown actions
diff --git a/app/core/message_handling/credex_bot_service.py b/app/core/message_handling/credex_bot_service.py
index 2b497d4..4e22073 100644
--- a/app/core/message_handling/credex_bot_service.py
+++ b/app/core/message_handling/credex_bot_service.py
@@ -9,7 +9,9 @@ from ..utils.exceptions import InvalidInputException
 from ..utils.error_handler import error_decorator
 
 # Set up logging
-logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+logging.basicConfig(
+    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
+)
 logger = logging.getLogger(__name__)
 
 
@@ -22,7 +24,7 @@ class CredexBotService:
 
         self.message = payload
         self.user = user
-        self.body = self.message.get('message', '')
+        self.body = self.message.get("message", "")
 
         self.state = self.user.state
         self.current_state = self.state.get_state(self.user)
diff --git a/app/core/message_handling/message_handling.py b/app/core/message_handling/message_handling.py
index 5d68fea..572a6fa 100644
--- a/app/core/message_handling/message_handling.py
+++ b/app/core/message_handling/message_handling.py
@@ -13,15 +13,17 @@ logger = logging.getLogger(__name__)
 
 def validate_input(input_text):
     if len(input_text) > 1000:
-        raise InvalidInputException("Input is too long. Please limit your message to 1000 characters.")
+        raise InvalidInputException(
+            "Input is too long. Please limit your message to 1000 characters."
+        )
 
-    if '@' in input_text:
+    if "@" in input_text:
         try:
             validate_email(input_text)
         except ValidationError:
             raise InvalidInputException("Invalid email format.")
 
-    disallowed_chars = ['<', '>', '{', '}', '[', ']']
+    disallowed_chars = ["<", ">", "{", "}", "[", "]"]
     if any(char in input_text for char in disallowed_chars):
         raise InvalidInputException("Input contains disallowed characters.")
 
@@ -49,7 +51,9 @@ class MessageHandler:
             return router.handle(sanitized_body, self.bot_service)
         except InvalidInputException as e:
             logger.error(f"Input validation failed: {str(e)}")
-            return wrap_text(f"Invalid input: {str(e)}", self.bot_service.user.mobile_number)
+            return wrap_text(
+                f"Invalid input: {str(e)}", self.bot_service.user.mobile_number
+            )
 
     @staticmethod
     def is_greeting(message):
@@ -64,20 +68,39 @@ class MessageHandler:
         success, message = self.bot_service.api_interactions.login()
 
         if success:
-            self.bot_service.state.update_state(self.bot_service.current_state, "handle_action_select_profile",
-                                                "handle", "handle_greeting")
-            return wrap_text(f"Welcome back! {message}\nHow can I assist you today?",
-                             self.bot_service.user.mobile_number)
+            self.bot_service.state.update_state(
+                self.bot_service.current_state,
+                "handle_action_select_profile",
+                "handle",
+                "handle_greeting",
+            )
+            return wrap_text(
+                f"Welcome back! {message}\nHow can I assist you today?",
+                self.bot_service.user.mobile_number,
+            )
         else:
             if "new user" in message.lower() or "invalid phone" in message.lower():
-                self.bot_service.state.update_state(self.bot_service.current_state, "handle_action_register", "handle",
-                                                    "handle_greeting")
-                return wrap_text(REGISTER.format(message=message), self.bot_service.user.mobile_number,
-                                 extra_rows=[{"id": '1', "title": "Become a member"}])
+                self.bot_service.state.update_state(
+                    self.bot_service.current_state,
+                    "handle_action_register",
+                    "handle",
+                    "handle_greeting",
+                )
+                return wrap_text(
+                    REGISTER.format(message=message),
+                    self.bot_service.user.mobile_number,
+                    extra_rows=[{"id": "1", "title": "Become a member"}],
+                )
             else:
-                self.bot_service.state.update_state(self.bot_service.current_state, "handle_action_register", "handle",
-                                                    "handle_greeting")
-                return registration_form(self.bot_service.user.mobile_number, message=message)
+                self.bot_service.state.update_state(
+                    self.bot_service.current_state,
+                    "handle_action_register",
+                    "handle",
+                    "handle_greeting",
+                )
+                return registration_form(
+                    self.bot_service.user.mobile_number, message=message
+                )
             # wrap_text(f"Login failed: {message}\nPlease try again later or contact support.", )
 
     def handle_offer_credex(self):
@@ -86,7 +109,7 @@ class MessageHandler:
             self.bot_service.current_state,
             "handle_action_offer_credex",
             "handle",
-            "handle_action_offer_credex"
+            "handle_action_offer_credex",
         )
         return self.bot_service.offer_credex_handler.handle_action_offer_credex()
 
@@ -97,7 +120,7 @@ class MessageHandler:
 
         if f"{self.bot_service.body}".startswith("handle_"):
             action = self.bot_service.body
-        elif f"{self.bot_service.body}" == 'AcceptAllIncomingOffers':
+        elif f"{self.bot_service.body}" == "AcceptAllIncomingOffers":
             action = "handle_action_accept_all_incoming_offers"
         elif f"{self.bot_service.body}".startswith("accept_"):
             action = "handle_action_accept_offer"
diff --git a/app/core/message_handling/offer_credex_handler.py b/app/core/message_handling/offer_credex_handler.py
index 682ac83..92c4736 100644
--- a/app/core/message_handling/offer_credex_handler.py
+++ b/app/core/message_handling/offer_credex_handler.py
@@ -1,11 +1,13 @@
-from ..utils.utils import wrap_text, format_synopsis, CredexWhatsappService
-from ..config.constants import *
-from serializers.offers import OfferCredexSerializer
-import requests
 import json
-from decouple import config
 from datetime import datetime, timedelta
 
+import requests
+from decouple import config
+from serializers.offers import OfferCredexSerializer
+
+from ..config.constants import *
+from ..utils.utils import CredexWhatsappService, format_synopsis, wrap_text
+
 
 class OfferCredexHandler:
     """Offering Credex Handler"""
@@ -15,20 +18,25 @@ class OfferCredexHandler:
     def handle_action_offer_credex(self):
         state = self.service.state
         current_state = self.service.current_state
-        message = ''
+        message = ""
 
-        if not current_state.get('member'):
+        if not current_state.get("member"):
             self.service.refresh()
 
-        if not current_state.get('member', {}).get('defaultAccountData', {}):
-            for account in current_state['member']['accountDashboards']:
-                if current_state['member']['memberDashboard']['accountIDS'][-1] == account.get('accountID'):
-                    current_state['member']['defaultAccountData'] = account
+        if not current_state.get("member", {}).get("defaultAccountData", {}):
+            for account in current_state["member"]["accountDashboards"]:
+                if current_state["member"]["memberDashboard"]["accountIDS"][
+                    -1
+                ] == account.get("accountID"):
+                    current_state["member"]["defaultAccountData"] = account
                     break
 
         payload = {}
-        if "=>" in f"{self.service.body}" or "->" in f"{self.service.body}" or self.service.message[
-            'type'] == "nfm_reply":
+        if (
+            "=>" in f"{self.service.body}"
+            or "->" in f"{self.service.body}"
+            or self.service.message["type"] == "nfm_reply"
+        ):
             payload = self._create_payload(current_state)
 
             serializer = OfferCredexSerializer(data=payload)
@@ -44,7 +52,7 @@ class OfferCredexHandler:
 
     def _create_payload(self, current_state):
         payload = {}
-        if self.service.message['type'] == "nfm_reply":
+        if self.service.message["type"] == "nfm_reply":
             payload = self._create_nfm_reply_payload(current_state)
         elif "=>" in self.service.body:
             payload = self._create_secured_credex_payload(current_state)
@@ -54,101 +62,131 @@ class OfferCredexHandler:
 
     def _create_nfm_reply_payload(self, current_state):
         return {
-            "authorizer_member_id": current_state['member']['memberDashboard'].get('memberID'),
-            "issuer_member_id": current_state['member']['defaultAccountData'].get('accountID') if current_state.get(
-                'member', {}).get('defaultAccountData', {}) else
-            current_state['member']['memberDashboard']['accountIDS'][-1],
-            "handle": self.service.body.get('handle'),
-            "amount": self.service.body.get('amount'),
-            "dueDate": self.service.body.get('due_date') if self.service.body.get('due_date') else (
-                                                                                                               datetime.now() + timedelta(
-                                                                                                           weeks=4)).timestamp() * 1000,
-            "currency": self.service.body.get('currency'),
-            "securedCredex": True
+            "authorizer_member_id": current_state["member"]["memberDashboard"].get(
+                "memberID"
+            ),
+            "issuer_member_id": (
+                current_state["member"]["defaultAccountData"].get("accountID")
+                if current_state.get("member", {}).get("defaultAccountData", {})
+                else current_state["member"]["memberDashboard"]["accountIDS"][-1]
+            ),
+            "handle": self.service.body.get("handle"),
+            "amount": self.service.body.get("amount"),
+            "dueDate": (
+                self.service.body.get("due_date")
+                if self.service.body.get("due_date")
+                else (datetime.now() + timedelta(weeks=4)).timestamp() * 1000
+            ),
+            "currency": self.service.body.get("currency"),
+            "securedCredex": True,
         }
 
     def _create_secured_credex_payload(self, current_state):
-        amount, user = f"{self.service.body}".split('=>')
+        amount, user = f"{self.service.body}".split("=>")
         if "=" in user:
             user, _ = user.split("=")
         return {
-            "authorizer_member_id": current_state['member']['memberDashboard'].get('memberID'),
-            "issuer_member_id": current_state['member']['defaultAccountData'].get('accountID') if current_state.get(
-                'member', {}).get('defaultAccountData', {}) else
-            current_state['member']['memberDashboard']['accountIDS'][-1],
+            "authorizer_member_id": current_state["member"]["memberDashboard"].get(
+                "memberID"
+            ),
+            "issuer_member_id": (
+                current_state["member"]["defaultAccountData"].get("accountID")
+                if current_state.get("member", {}).get("defaultAccountData", {})
+                else current_state["member"]["memberDashboard"]["accountIDS"][-1]
+            ),
             "handle": user,
             "amount": amount,
             "dueDate": (datetime.now()).timestamp() * 1000,
-            "currency": current_state['member']['defaultAccountData']['defaultDenom'] if current_state.get('member',
-                                                                                                           {}).get(
-                'defaultAccountData', {}) else current_state['member']['memberDashboard'].get('defaultDenom'),
-            "securedCredex": True
+            "currency": (
+                current_state["member"]["defaultAccountData"]["defaultDenom"]
+                if current_state.get("member", {}).get("defaultAccountData", {})
+                else current_state["member"]["memberDashboard"].get("defaultDenom")
+            ),
+            "securedCredex": True,
         }
 
     def _create_unsecured_credex_payload(self, current_state):
-        if '=' in f"{self.service.body}":
-            amount, user_date = f"{self.service.body}".split('->')
-            user, date = user_date.split('=')
+        if "=" in f"{self.service.body}":
+            amount, user_date = f"{self.service.body}".split("->")
+            user, date = user_date.split("=")
             try:
-                due_date = datetime.strptime(date, '%Y-%m-%d').timestamp() * 1000
+                due_date = datetime.strptime(date, "%Y-%m-%d").timestamp() * 1000
             except ValueError:
-                raise ValueError('Invalid Due Date')
+                raise ValueError("Invalid Due Date")
         else:
-            amount, user = f"{self.service.body}".split('->')
+            amount, user = f"{self.service.body}".split("->")
             due_date = (datetime.now() + timedelta(weeks=4)).timestamp() * 1000
 
         return {
-            "authorizer_member_id": current_state['member']['memberDashboard'].get('memberID'),
-            "issuer_member_id": current_state['member']['defaultAccountData'].get('accountID') if current_state.get(
-                'member', {}).get('defaultAccountData', {}) else
-            current_state['member']['memberDashboard']['accountIDS'][-1],
+            "authorizer_member_id": current_state["member"]["memberDashboard"].get(
+                "memberID"
+            ),
+            "issuer_member_id": (
+                current_state["member"]["defaultAccountData"].get("accountID")
+                if current_state.get("member", {}).get("defaultAccountData", {})
+                else current_state["member"]["memberDashboard"]["accountIDS"][-1]
+            ),
             "handle": user,
             "amount": amount,
             "dueDate": due_date,
-            "currency": current_state['member']['defaultAccountData']['defaultDenom'] if current_state.get('member',
-                                                                                                           {}).get(
-                'defaultAccountData', {}) else current_state['member']['memberDashboard'].get('defaultDenom'),
-            "securedCredex": False
+            "currency": (
+                current_state["member"]["defaultAccountData"]["defaultDenom"]
+                if current_state.get("member", {}).get("defaultAccountData", {})
+                else current_state["member"]["memberDashboard"].get("defaultDenom")
+            ),
+            "securedCredex": False,
         }
 
     def _handle_valid_serializer(self, serializer, current_state, state):
         accounts = self._get_accounts(current_state)
-        response = self._create_confirmation_message(serializer, current_state, accounts)
-        current_state['confirm_offer_payload'] = serializer.validated_data
-        current_state['confirm_offer_payload']['secured'] = serializer.validated_data['securedCredex']
+        response = self._create_confirmation_message(
+            serializer, current_state, accounts
+        )
+        current_state["confirm_offer_payload"] = serializer.validated_data
+        current_state["confirm_offer_payload"]["secured"] = serializer.validated_data[
+            "securedCredex"
+        ]
         state.update_state(
             state=current_state,
-            stage='handle_action_offer_credex',
+            stage="handle_action_offer_credex",
             update_from="handle_action_offer_credex",
-            option="handle_action_confirm_offer_credex"
+            option="handle_action_confirm_offer_credex",
         )
         return self._create_confirmation_response(response, accounts)
 
     def _handle_invalid_serializer(self, serializer):
         for err in serializer.errors.keys():
             if "This field is required." != serializer.errors[err][0]:
-                return f'*{serializer.errors[err][0]}❗*'
-        return 'Invalid input'
+                return f"*{serializer.errors[err][0]}❗*"
+        return "Invalid input"
 
     def _handle_confirm_offer_credex(self, current_state, state):
-        to_credex = current_state.get('confirm_offer_payload')
-        to_credex['issuerAccountID'] = current_state['member']['defaultAccountData'].get('accountID')
-        if self.service.message['type'] == "nfm_reply":
-            to_credex['issuerAccountID'] = self.service.message['message']['source_account']
+        to_credex = current_state.get("confirm_offer_payload")
+        to_credex["issuerAccountID"] = current_state["member"][
+            "defaultAccountData"
+        ].get("accountID")
+        if self.service.message["type"] == "nfm_reply":
+            to_credex["issuerAccountID"] = self.service.message["message"][
+                "source_account"
+            ]
 
-        to_credex['memberID'] = current_state['member']['memberDashboard'].get('memberID')
+        to_credex["memberID"] = current_state["member"]["memberDashboard"].get(
+            "memberID"
+        )
         to_credex.pop("handle", None)
-        if to_credex.get('securedCredex'):
-            to_credex.pop('dueDate', None)
+        if to_credex.get("securedCredex"):
+            to_credex.pop("dueDate", None)
 
-        to_credex.pop('secured', None)
-        payload = current_state.get('confirm_offer_payload')
+        to_credex.pop("secured", None)
+        payload = current_state.get("confirm_offer_payload")
         headers = {
-            'X-Github-Token': config('CREDEX_API_CREDENTIALS'),
-            'Content-Type': 'application/json',
-            'whatsappBotAPIkey': config('WHATSAPP_BOT_API_KEY'),
+            "X-Github-Token": config("CREDEX_API_CREDENTIALS"),
+            "Content-Type": "application/json",
+            "whatsappBotAPIkey": config("CLIENT_API_KEY"),
         }
-        response = requests.request("POST", f"{config('CREDEX')}/offerCredex", headers=headers, data=payload)
+        response = requests.request(
+            "POST", f"{config('CREDEX')}/offerCredex", headers=headers, data=payload
+        )
 
         if response.status_code == 200:
             return self._handle_successful_offer(response, current_state, state)
@@ -164,9 +203,7 @@ class OfferCredexHandler:
             "type": "interactive",
             "interactive": {
                 "type": "flow",
-                "body": {
-                    "text": OFFER_CREDEX.format(message=format_synopsis(message))
-                },
+                "body": {"text": OFFER_CREDEX.format(message=format_synopsis(message))},
                 "action": {
                     "name": "flow",
                     "parameters": {
@@ -178,48 +215,58 @@ class OfferCredexHandler:
                         "flow_action_payload": {
                             "screen": "MAKE_SECURE_OFFER",
                             "data": {
-                                "min_date": str((datetime.now() + timedelta(days=1)).timestamp() * 1000),
-                                "max_date": str((datetime.now() + timedelta(weeks=5)).timestamp() * 1000)
-                            }
-                        }
-                    }
-                }
-            }
+                                "min_date": str(
+                                    (datetime.now() + timedelta(days=1)).timestamp()
+                                    * 1000
+                                ),
+                                "max_date": str(
+                                    (datetime.now() + timedelta(weeks=5)).timestamp()
+                                    * 1000
+                                ),
+                            },
+                        },
+                    },
+                },
+            },
         }
 
     def _get_accounts(self, current_state):
         accounts = []
-        for account in current_state['member']['accountDashboards']:
-            accounts.append({
-                "id": account.get('accountID'),
-                "title": f"👤 {account.get('accountName')}"
-            })
+        for account in current_state["member"]["accountDashboards"]:
+            accounts.append(
+                {
+                    "id": account.get("accountID"),
+                    "title": f"👤 {account.get('accountName')}",
+                }
+            )
             if len(accounts) >= 8:
                 break
         return accounts
 
     def _create_confirmation_message(self, serializer, current_state, accounts):
-        account_string = "\n".join([f" *{i + 1}.*  _{acc['title']}_" for i, acc in enumerate(accounts)])
-        if serializer.validated_data.get('securedCredex'):
+        account_string = "\n".join(
+            [f" *{i + 1}.*  _{acc['title']}_" for i, acc in enumerate(accounts)]
+        )
+        if serializer.validated_data.get("securedCredex"):
             return CONFIRM_SECURED_CREDEX.format(
-                party=serializer.validated_data.get('full_name'),
-                amount=serializer.validated_data.get('InitialAmount'),
-                currency=serializer.validated_data.get('Denomination'),
-                source=current_state['member']['defaultAccountData'].get('accountName'),
-                handle=serializer.validated_data.pop('handle'),
-                secured='*secured*',
-                accounts=account_string
+                party=serializer.validated_data.get("full_name"),
+                amount=serializer.validated_data.get("InitialAmount"),
+                currency=serializer.validated_data.get("Denomination"),
+                source=current_state["member"]["defaultAccountData"].get("accountName"),
+                handle=serializer.validated_data.pop("handle"),
+                secured="*secured*",
+                accounts=account_string,
             )
         else:
             return CONFIRM_UNSECURED_CREDEX.format(
-                party=serializer.validated_data.get('full_name'),
-                amount=serializer.validated_data.get('InitialAmount'),
-                currency=serializer.validated_data.get('Denomination'),
-                source=current_state['member']['defaultAccountData'].get('accountName'),
-                handle=serializer.validated_data.pop('handle'),
-                secured='*unsecured*',
+                party=serializer.validated_data.get("full_name"),
+                amount=serializer.validated_data.get("InitialAmount"),
+                currency=serializer.validated_data.get("Denomination"),
+                source=current_state["member"]["defaultAccountData"].get("accountName"),
+                handle=serializer.validated_data.pop("handle"),
+                secured="*unsecured*",
                 date=f"*Due Date :* {serializer.validated_data.get('dueDate')}",
-                accounts=account_string
+                accounts=account_string,
             )
 
     def _create_confirmation_response(self, response, accounts):
@@ -230,9 +277,7 @@ class OfferCredexHandler:
             "type": "interactive",
             "interactive": {
                 "type": "flow",
-                "body": {
-                    "text": response
-                },
+                "body": {"text": response},
                 "action": {
                     "name": "flow",
                     "parameters": {
@@ -243,23 +288,22 @@ class OfferCredexHandler:
                         "flow_cta": "Sign & Send",
                         "flow_action_payload": {
                             "screen": "OFFER_SECURED_CREDEX",
-                            "data": {
-                                "source_account": accounts
-                            }
-                        }
-                    }
-                }
-            }
+                            "data": {"source_account": accounts},
+                        },
+                    },
+                },
+            },
         }
 
     def _handle_successful_offer(self, response, current_state, state):
         response_data = response.json()
         if response_data.get("offerCredexData", {}).get("credex"):
             credex_data = response_data.get("offerCredexData", {})
-            current_state.pop('confirm_offer_payload', {})
-            denom = current_state['member']['defaultAccountData']['defaultDenom']
-            current_state.pop('defaultAccountData', {})
-            CredexWhatsappService(payload={
+            current_state.pop("confirm_offer_payload", {})
+            denom = current_state["member"]["defaultAccountData"]["defaultDenom"]
+            current_state.pop("defaultAccountData", {})
+            CredexWhatsappService(
+                payload={
                     "messaging_product": "whatsapp",
                     "preview_url": False,
                     "recipient_type": "individual",
@@ -267,45 +311,70 @@ class OfferCredexHandler:
                     "type": "text",
                     "text": {
                         "body": OFFER_SUCCESSFUL.format(
-                        type='Secured Credex' if credex_data['credex']['secured'] else 'Unsecured Credex',
-                        amount=credex_data['credex']['formattedInitialAmount'],
+                            type=(
+                                "Secured Credex"
+                                if credex_data["credex"]["secured"]
+                                else "Unsecured Credex"
+                            ),
+                            amount=credex_data["credex"]["formattedInitialAmount"],
                             currency=denom,
-                        recipient=credex_data['credex']['counterpartyAccountName'],
-                        source=current_state['member']['defaultAccountData'].get('accountName'),
-                        secured='*Secured* credex' if credex_data['credex']['secured'] else '*Unsecured* credex',
+                            recipient=credex_data["credex"]["counterpartyAccountName"],
+                            source=current_state["member"]["defaultAccountData"].get(
+                                "accountName"
+                            ),
+                            secured=(
+                                "*Secured* credex"
+                                if credex_data["credex"]["secured"]
+                                else "*Unsecured* credex"
+                            ),
                         )
+                    },
                 }
-            }).notify()
+            ).notify()
             self._update_current_state(current_state)
             state.update_state(
                 state=current_state,
-                stage='handle_action_menu',
+                stage="handle_action_menu",
                 update_from="handle_action_menu",
-                option="handle_action_menu"
+                option="handle_action_menu",
             )
 
             self.service.refresh(reset=True)
-            self.service.body = current_state['member']['defaultAccountData'].get('accountHandle')
+            self.service.body = current_state["member"]["defaultAccountData"].get(
+                "accountHandle"
+            )
             return self.service.action_handler.handle_action_select_profile()
         else:
-            current_state.pop('confirm_offer_payload', {})
-            message = format_synopsis(response_data.get("offerCredexData", {}).get('message', '').replace("Error:", ""))
+            current_state.pop("confirm_offer_payload", {})
+            message = format_synopsis(
+                response_data.get("offerCredexData", {})
+                .get("message", "")
+                .replace("Error:", "")
+            )
             return self._create_offer_credex_response(current_state, state, message)
 
     def _handle_failed_offer(self, response, current_state):
-        current_state.pop('confirm_offer_payload', {})
+        current_state.pop("confirm_offer_payload", {})
         try:
             message = format_synopsis(
-                response.json().get("offerCredexData", {}).get('message', '').replace("Error:", ""))
+                response.json()
+                .get("offerCredexData", {})
+                .get("message", "")
+                .replace("Error:", "")
+            )
         except Exception:
-            message = 'Failed to process the offer'
-        return wrap_text(OFFER_FAILED.format(message=message), self.service.user.mobile_number, x_is_menu=True,
-                         back_is_cancel=False)
+            message = "Failed to process the offer"
+        return wrap_text(
+            OFFER_FAILED.format(message=message),
+            self.service.user.mobile_number,
+            x_is_menu=True,
+            back_is_cancel=False,
+        )
 
     def _update_current_state(self, current_state):
-        default = current_state['member']['defaultAccountData'].get('accountID')
-        current_state.get('member', {}).pop('defaultAccountData', {})
-        for account in current_state['member']['accountDashboards']:
-            if default == account.get('accountID'):
-                current_state['member']['defaultAccountData'] = account
+        default = current_state["member"]["defaultAccountData"].get("accountID")
+        current_state.get("member", {}).pop("defaultAccountData", {})
+        for account in current_state["member"]["accountDashboards"]:
+            if default == account.get("accountID"):
+                current_state["member"]["defaultAccountData"] = account
                 break
diff --git a/app/core/message_handling/router.py b/app/core/message_handling/router.py
index 4f9513c..64f01d8 100644
--- a/app/core/message_handling/router.py
+++ b/app/core/message_handling/router.py
@@ -27,26 +30,30 @@ class Router:
         return bot_service.action_handler.handle_default_action()
 
     def _match_pattern(self, pattern, message):
-        if pattern == 'greeting':
+        if pattern == "greeting":
             return message.lower() in GREETINGS
-        elif pattern == 'offer_credex':
+        elif pattern == "offer_credex":
             return "=>" in message or "->" in message
-        elif pattern.startswith('handle_action_'):
+        elif pattern.startswith("handle_action_"):
             return message.startswith(pattern)
         else:
             return pattern == message
 
+
 router = Router()
 
-@router.route('greeting')
+
+@router.route("greeting")
 def handle_greeting(bot_service):
     return bot_service.message_handler.handle_greeting()
 
-@router.route('offer_credex')
+
+@router.route("offer_credex")
 def handle_offer_credex(bot_service):
     return bot_service.message_handler.handle_offer_credex()
 
-@router.route('handle_action_')
+
+@router.route("handle_action_")
 def handle_action(bot_service):
     return bot_service.message_handler.handle_action()
 
diff --git a/app/core/message_handling/whatsapp_forms.py b/app/core/message_handling/whatsapp_forms.py
index b7d1061..4d3d08d 100644
--- a/app/core/message_handling/whatsapp_forms.py
+++ b/app/core/message_handling/whatsapp_forms.py
@@ -12,9 +12,7 @@ def registration_form(mobile_number, message):
         "type": "interactive",
         "interactive": {
             "type": "flow",
-            "body": {
-                "text": REGISTER.format(message=message)
-            },
+            "body": {"text": REGISTER.format(message=message)},
             "action": {
                 "name": "flow",
                 "parameters": {
@@ -23,12 +21,10 @@ def registration_form(mobile_number, message):
                     "flow_token": "not-used",
                     "flow_id": "3686836301579704",
                     "flow_cta": "Create Account",
-                    "flow_action_payload": {
-                        "screen": "MEMBER_SIGNUP"
-                    }
-                }
-            }
-        }
+                    "flow_action_payload": {"screen": "MEMBER_SIGNUP"},
+                },
+            },
+        },
     }
 
 
@@ -40,9 +36,7 @@ def offer_credex(mobile_number, message):
         "type": "interactive",
         "interactive": {
             "type": "flow",
-            "body": {
-                "text": OFFER_CREDEX.format(message=message)
-            },
+            "body": {"text": OFFER_CREDEX.format(message=message)},
             "action": {
                 "name": "flow",
                 "parameters": {
@@ -54,13 +48,15 @@ def offer_credex(mobile_number, message):
                     "flow_action_payload": {
                         "screen": "MAKE_SECURE_OFFER",
                         "data": {
-                            "min_date": str((datetime.now() + timedelta(days=1)).timestamp() * 1000),
-                            "max_date": str((datetime.now() + timedelta(weeks=5)).timestamp() * 1000)
-
-                        }
-                    }
-                }
-            }
-        }
-
+                            "min_date": str(
+                                (datetime.now() + timedelta(days=1)).timestamp() * 1000
+                            ),
+                            "max_date": str(
+                                (datetime.now() + timedelta(weeks=5)).timestamp() * 1000
+                            ),
+                        },
+                    },
+                },
+            },
+        },
     }
diff --git a/app/core/migrations/0001_initial.py b/app/core/migrations/0001_initial.py
index f602d64..b0a60db 100644
--- a/app/core/migrations/0001_initial.py
+++ b/app/core/migrations/0001_initial.py
@@ -7,15 +7,22 @@ class Migration(migrations.Migration):
 
     initial = True
 
-    dependencies = [
-    ]
+    dependencies = []
 
     operations = [
         migrations.CreateModel(
-            name='Message',
+            name="Message",
             fields=[
-                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
-                ('messsage', models.TextField()),
+                (
+                    "id",
+                    models.BigAutoField(
+                        auto_created=True,
+                        primary_key=True,
+                        serialize=False,
+                        verbose_name="ID",
+                    ),
+                ),
+                ("messsage", models.TextField()),
             ],
         ),
     ]
diff --git a/app/core/migrations/0002_message_last_updated.py b/app/core/migrations/0002_message_last_updated.py
index 74b9fd2..24ccba0 100644
--- a/app/core/migrations/0002_message_last_updated.py
+++ b/app/core/migrations/0002_message_last_updated.py
@@ -6,13 +6,13 @@ from django.db import migrations, models
 class Migration(migrations.Migration):
 
     dependencies = [
-        ('core', '0001_initial'),
+        ("core", "0001_initial"),
     ]
 
     operations = [
         migrations.AddField(
-            model_name='message',
-            name='last_updated',
+            model_name="message",
+            name="last_updated",
             field=models.DateTimeField(auto_now=True),
         ),
     ]
diff --git a/app/core/state/state_management.py b/app/core/state/state_management.py
index 38f81e7..a2307e7 100644
--- a/app/core/state/state_management.py
+++ b/app/core/state/state_management.py
@@ -11,17 +11,18 @@ class StateManager:
         return self.core_service.state.get_state(self.core_service.user)
 
     def update_state(self, new_state, stage, update_from, option):
-        logger.info(f"Updating state: stage={stage}, update_from={update_from}, option={option}")
+        logger.info(
+            f"Updating state: stage={stage}, update_from={update_from}, option={option}"
+        )
         print("INITIAL STAGE: ", self.core_service.user.state.stage)
         self.core_service.user.state.update_state(
-            state=new_state,
-            stage=stage,
-            update_from=update_from,
-            option=option
+            state=new_state, stage=stage, update_from=update_from, option=option
         )
         print("UPDATED STAGE: ", self.core_service.user.state.stage)
 
-        self.core_service.state = self.core_service.state.get_state(self.core_service.user)
+        self.core_service.state = self.core_service.state.get_state(
+            self.core_service.user
+        )
 
     def reset_state(self):
         logger.info("Resetting state")
@@ -35,21 +36,21 @@ class StateManager:
         self.core_service.state.stage = stage
 
     def get_current_option(self):
-        return self.core_service.current_state.get('option')
+        return self.core_service.current_state.get("option")
 
     def set_current_option(self, option):
         logger.info(f"Setting current option to: {option}")
-        self.core_service.current_state['option'] = option
+        self.core_service.current_state["option"] = option
 
     def get_member_info(self):
-        return self.core_service.current_state.get('member', {})
+        return self.core_service.current_state.get("member", {})
 
     def update_member_info(self, new_info):
         logger.info("Updating member info")
-        if 'member' not in self.core_service.current_state:
-            self.core_service.current_state['member'] = {}
-        self.core_service.current_state['member'].update(new_info)
+        if "member" not in self.core_service.current_state:
+            self.core_service.current_state["member"] = {}
+        self.core_service.current_state["member"].update(new_info)
 
     def clear_member_info(self):
         logger.info("Clearing member info")
-        self.core_service.current_state['member'] = {}
+        self.core_service.current_state["member"] = {}
diff --git a/app/core/utils/audit_logging.py b/app/core/utils/audit_logging.py
index dcb7e4a..45ab2af 100644
--- a/app/core/utils/audit_logging.py
+++ b/app/core/utils/audit_logging.py
@@ -2,15 +2,15 @@ import logging
 from datetime import datetime
 
 # Configure the logger
-logger = logging.getLogger('audit')
+logger = logging.getLogger("audit")
 logger.setLevel(logging.INFO)
 
 # Create a file handler
-handler = logging.FileHandler('audit.log')
+handler = logging.FileHandler("audit.log")
 handler.setLevel(logging.INFO)
 
 # Create a logging format
-formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
 handler.setFormatter(formatter)
 
 # Add the handler to the logger
diff --git a/app/core/utils/credex_bot_utils.py b/app/core/utils/credex_bot_utils.py
index 01cac36..43f3aeb 100644
--- a/app/core/utils/credex_bot_utils.py
+++ b/app/core/utils/credex_bot_utils.py
@@ -4,20 +4,22 @@ from ..config.constants import REGISTER, GREETINGS
 
 logger = logging.getLogger(__name__)
 
+
 def update_current_state(response_data, current_state, reset):
     if reset:
-        current_state['member'] = response_data
+        current_state["member"] = response_data
     else:
-        current_state['member'].update(response_data)
+        current_state["member"].update(response_data)
     logger.info("Current state updated")
 
+
 def handle_successful_refresh(current_state, state, bot_service):
     logger.info("Refresh successful")
     state.update_state(
         state=current_state,
-        stage='handle_action_select_profile',
+        stage="handle_action_select_profile",
         update_from="refresh",
-        option="select_account_to_use"
+        option="select_account_to_use",
     )
     return bot_service.action_handler.handle_action_select_profile()
 
@@ -25,11 +28,17 @@ def handle_failed_refresh(current_state, state, error_message, bot_service):
     logger.error(f"Refresh failed: {error_message}")
     state.update_state(
         state=current_state,
-        stage='handle_action_register',
+        stage="handle_action_register",
         update_from="refresh",
-        option="handle_action_register"
+        option="handle_action_register",
     )
-    return wrap_text(REGISTER.format(message=error_message), bot_service.user.mobile_number, extra_rows=[{"id": '1', "title": "Become a member"}], include_menu=False)
+    return wrap_text(
+        REGISTER.format(message=error_message),
+        bot_service.user.mobile_number,
+        extra_rows=[{"id": "1", "title": "Become a member"}],
+        include_menu=False,
+    )
+
 
 def handle_message(bot_service):
     logger.info("Handling default action")
@@ -37,22 +46,37 @@ def handle_message(bot_service):
     logger.info(f"Final state: {bot_service.state.stage}")
     return response
 
+
 def handle_offer_credex(bot_service):
     logger.info("Handling offer credex action")
-    bot_service.state.update_state(bot_service.current_state, "handle_action_offer_credex", "handle", "handle_action_offer_credex")
+    bot_service.state.update_state(
+        bot_service.current_state,
+        "handle_action_offer_credex",
+        "handle",
+        "handle_action_offer_credex",
+    )
     return bot_service.offer_credex_handler.handle_action_offer_credex()
 
+
 def handle_action(bot_service):
     action_method = getattr(bot_service.action_handler, bot_service.body, None)
     if action_method and callable(action_method):
         logger.info(f"Handling action: {bot_service.body}")
-        bot_service.state.update_state(bot_service.current_state, bot_service.body, "handle", bot_service.body)
+        bot_service.state.update_state(
+            bot_service.current_state, bot_service.body, "handle", bot_service.body
+        )
         return action_method()
     else:
         logger.warning(f"Action method {bot_service.body} not found")
         return bot_service.action_handler.handle_default_action()
 
+
 def handle_greeting(bot_service):
     logger.info("Handling greeting")
-    bot_service.state.update_state(bot_service.current_state, "handle_action_select_profile", "handle", "handle_greeting")
+    bot_service.state.update_state(
+        bot_service.current_state,
+        "handle_action_select_profile",
+        "handle",
+        "handle_greeting",
+    )
     return bot_service.action_handler.handle_greeting()
diff --git a/app/core/utils/error_handler.py b/app/core/utils/error_handler.py
index fe27000..9fef09b 100644
--- a/app/core/utils/error_handler.py
+++ b/app/core/utils/error_handler.py
@@ -5,7 +5,7 @@ from .exceptions import (
     APIException,
     StateException,
     ActionHandlerException,
-    ConfigurationException
+    ConfigurationException,
 )
 from .utils import wrap_text
 
@@ -16,13 +17,19 @@ def handle_error(e, bot_service):
     if isinstance(e, InvalidInputException):
         message = "Sorry, I couldn't understand your input. Please try again."
     elif isinstance(e, APIException):
-        message = "We're experiencing some technical difficulties. Please try again later."
+        message = (
+            "We're experiencing some technical difficulties. Please try again later."
+        )
     elif isinstance(e, StateException):
         message = "There was an issue with your current session. Please start over."
     elif isinstance(e, ActionHandlerException):
-        message = "I encountered an error while processing your request. Please try again."
+        message = (
+            "I encountered an error while processing your request. Please try again."
+        )
     elif isinstance(e, ConfigurationException):
-        message = "There's a configuration issue on our end. Our team has been notified."
+        message = (
+            "There's a configuration issue on our end. Our team has been notified."
+        )
     elif isinstance(e, CredExBotException):
         message = "An unexpected error occurred. Please try again or contact support."
     else:
@@ -37,5 +46,8 @@ def error_decorator(f):
         try:
             return f(*args, **kwargs)
         except Exception as e:
-            return handle_error(e, args[0])  # Assuming the first argument is always bot_service
+            return handle_error(
+                e, args[0]
+            )  # Assuming the first argument is always bot_service
+
     return wrapper
diff --git a/app/core/utils/utils.py b/app/core/utils/utils.py
index e36d827..46c78de 100644
--- a/app/core/utils/utils.py
+++ b/app/core/utils/utils.py
@@ -22,30 +22,24 @@ def format_synopsis(synopsis, style=None, max_line_length=35):
 
 
 def wrap_text(
-        message, user_mobile_number, 
-        proceed_option=False, x_is_menu=False,
-        navigate_is="Respond",extra_rows=[],
-        number=None, use_buttons=False, 
-        yes_or_no=False, custom=dict,
-        plain=False, include_menu=True
+    message,
+    user_mobile_number,
+    proceed_option=False,
+    x_is_menu=False,
+    navigate_is="Respond",
+    extra_rows=[],
+    number=None,
+    use_buttons=False,
+    yes_or_no=False,
+    custom=dict,
+    plain=False,
+    include_menu=True,
 ):
     print("MESSAGE : ", message)
     if use_buttons:
         rows = [
-            {
-                "type": "reply",
-                "reply": {
-                    "id": "N",
-                    "title": "❌ No"
-                }
-            },
-            {
-                "type": "reply",
-                "reply": {
-                    "id": "Y",
-                    "title": "✅ Yes"
-                }
-            }
+            {"type": "reply", "reply": {"id": "N", "title": "❌ No"}},
+            {"type": "reply", "reply": {"id": "Y", "title": "✅ Yes"}},
         ]
         return {
             "messaging_product": "whatsapp",
@@ -54,21 +48,29 @@ def wrap_text(
             "type": "interactive",
             "interactive": {
                 "type": "button",
-                "body": {
-                    "text": message
-                },
+                "body": {"text": message},
                 "action": {
-                    "buttons": [
+                    "buttons": (
+                        [
                             {
                                 "type": "reply",
-                            "reply": custom if custom else {
+                                "reply": (
+                                    custom
+                                    if custom
+                                    else {
                                         "id": "X",
-                                "title": "🏡 Menu" if x_is_menu else "❌ Cancel"
-                            }
-                        }
-                    ] if not yes_or_no else rows
+                                        "title": (
+                                            "🏡 Menu" if x_is_menu else "❌ Cancel"
+                                        ),
                                     }
+                                ),
                             }
+                        ]
+                        if not yes_or_no
+                        else rows
+                    )
+                },
+            },
         }
 
     if len(message) > 1024 or plain:
@@ -77,25 +79,16 @@ def wrap_text(
             "recipient_type": "individual",
             "to": number or user_mobile_number,
             "type": "text",
-            "text": {
-                "body": message
-            }
+            "text": {"body": message},
         }
 
     rows = extra_rows
 
     if proceed_option:
-        rows.append({
-            "id": "Y",
-            "title": "✅ Continue"
-        })
+        rows.append({"id": "Y", "title": "✅ Continue"})
 
     if include_menu:
-        rows.append({
-                "id": "X",
-                "title": "🏡 Menu"
-            }
-        )
+        rows.append({"id": "X", "title": "🏡 Menu"})
 
     row_data = []
     keystore = []
@@ -111,20 +104,12 @@ def wrap_text(
         "type": "interactive",
         "interactive": {
             "type": "list",
-            "body": {
-                "text": message
-            },
-            "action":
-                {
+            "body": {"text": message},
+            "action": {
                 "button": f"🕹️ {navigate_is}",
-                    "sections": [
-                        {
-                            "title": "Control",
-                            "rows": row_data
-                        }
-                    ]
-                }
-        }
+                "sections": [{"title": "Control", "rows": row_data}],
+            },
+        },
     }
 
 
@@ -137,8 +122,8 @@ class CredexWhatsappService:
         # Implementation for sending WhatsApp message
         url = f"{config('WHATSAPP_API_URL')}{self.phone_number_id}/messages"
         headers = {
-            'Authorization': f"Bearer {config('WHATSAPP_ACCESS_TOKEN')}",
-            'Content-Type': 'application/json'
+            "Authorization": f"Bearer {config('WHATSAPP_ACCESS_TOKEN')}",
+            "Content-Type": "application/json",
         }
         response = requests.post(url, json=self.payload, headers=headers)
         print(response.json())
@@ -150,7 +135,7 @@ class CredexWhatsappService:
 
 
 def convert_timestamp_to_date(timestamp):
-    return datetime.fromtimestamp(timestamp / 1000).strftime('%Y-%m-%d %H:%M:%S')
+    return datetime.fromtimestamp(timestamp / 1000).strftime("%Y-%m-%d %H:%M:%S")
 
 
 def get_greeting(name):
@@ -164,7 +149,7 @@ def get_greeting(name):
 
 
 def format_currency(amount, currency):
-    if currency.upper() == 'USD':
+    if currency.upper() == "USD":
         return f"${amount:.2f}"
     else:
         return f"{amount:.2f} {currency}"
@@ -172,10 +157,14 @@ def format_currency(amount, currency):
 
 def validate_phone_number(phone_number):
     # Basic validation, can be improved based on specific requirements
-    return phone_number.startswith('+') and len(phone_number) >= 10 and phone_number[1:].isdigit()
+    return (
+        phone_number.startswith("+")
+        and len(phone_number) >= 10
+        and phone_number[1:].isdigit()
+    )
 
 
-def mask_sensitive_info(text, mask_char='*'):
+def mask_sensitive_info(text, mask_char="*"):
     # Example implementation, can be customized based on specific requirements
     words = text.split()
     masked_words = []
@@ -185,7 +174,7 @@ def mask_sensitive_info(text, mask_char='*'):
         else:
             masked_word = mask_char * len(word)
         masked_words.append(masked_word)
-    return ' '.join(masked_words)
+    return " ".join(masked_words)
 
 
 def handle_api_error(response):
@@ -193,7 +182,7 @@ def handle_api_error(response):
         error_message = f"API Error: {response.status_code}"
         try:
             error_data = response.json()
-            if 'error' in error_data:
+            if "error" in error_data:
                 error_message += f" - {error_data['error']}"
         except ValueError:
             error_message += f" - {response.text}"
diff --git a/app/manage.py b/app/manage.py
index 8e7ac79..d28672e 100755
--- a/app/manage.py
+++ b/app/manage.py
@@ -6,7 +6,7 @@ import sys
 
 def main():
     """Run administrative tasks."""
-    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
+    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
     try:
         from django.core.management import execute_from_command_line
     except ImportError as exc:
@@ -18,5 +18,5 @@ def main():
     execute_from_command_line(sys.argv)
 
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     main()
diff --git a/app/serializers/company.py b/app/serializers/company.py
index eb7c85c..8cb5768 100644
--- a/app/serializers/company.py
+++ b/app/serializers/company.py
@@ -11,10 +11,9 @@ class CompanyDetailsSerializer(serializers.Serializer):
     def validate(self, attrs):
         super().validate(attrs)
         return {
-            "ownerID": attrs['ownerID'],
+            "ownerID": attrs["ownerID"],
             "accountType": "BUSINESS",
             "accountName": attrs["companyname"],
             "accountHandle": attrs["handle"],
-            "defaultDenom": attrs["defaultDenom"]
+            "defaultDenom": attrs["defaultDenom"],
         }
-
diff --git a/app/serializers/members.py b/app/serializers/members.py
index 11afc28..d86c0a6 100644
--- a/app/serializers/members.py
+++ b/app/serializers/members.py
@@ -8,18 +8,21 @@ class MemberDetailsSerializer(serializers.Serializer):
     phone_number = serializers.CharField(required=True)
 
     def validate(self, attrs):
-        attrs['full_name'] = f"{attrs.get('first_name')} {attrs.get('last_name')}"
-        if not re.match(r'(?i)(?:[a-zA-Z])+(?:\s[a-zA-Z]+)*(?:\s[a-zA-Z]+)?$', attrs.get('full_name')):
+        attrs["full_name"] = f"{attrs.get('first_name')} {attrs.get('last_name')}"
+        if not re.match(
+            r"(?i)(?:[a-zA-Z])+(?:\s[a-zA-Z]+)*(?:\s[a-zA-Z]+)?$",
+            attrs.get("full_name"),
+        ):
             raise serializers.ValidationError({"full_name": "Invalid name(s)"})
 
-        phone_number = attrs.get('phone_number').replace("+", "")
+        phone_number = attrs.get("phone_number").replace("+", "")
         if not phone_number.isdigit():
             raise serializers.ValidationError({"phone_number": "Invalid phone number"})
         return {
             # "memberType": "HUMAN",
-            "defaultDenom": 'USD',
-            "phone": attrs.get('phone_number'),
-            "firstname": attrs.get('first_name'),
-            "lastname": attrs.get('last_name')
+            "defaultDenom": "USD",
+            "phone": attrs.get("phone_number"),
+            "firstname": attrs.get("first_name"),
+            "lastname": attrs.get("last_name"),
             # "memberHandle": attrs.get('phone_number')
         }
diff --git a/app/serializers/offers.py b/app/serializers/offers.py
index 6d8ee99..c223be4 100644
--- a/app/serializers/offers.py
+++ b/app/serializers/offers.py
@@ -15,13 +15,18 @@ class OfferCredexSerializer(serializers.Serializer):
     securedCredex = serializers.BooleanField(required=True)
 
     def validate(self, attrs):
-        attrs['full_name'] = f"{attrs.get('first_name')} {attrs.get('last_name')}"
-        if not re.match(r'(?i)(?:[a-zA-Z])+(?:\s[a-zA-Z]+)*(?:\s[a-zA-Z]+)?$', attrs.get('full_name')):
+        attrs["full_name"] = f"{attrs.get('first_name')} {attrs.get('last_name')}"
+        if not re.match(
+            r"(?i)(?:[a-zA-Z])+(?:\s[a-zA-Z]+)*(?:\s[a-zA-Z]+)?$",
+            attrs.get("full_name"),
+        ):
             raise serializers.ValidationError({"full_name": "Invalid name(s)"})
 
-        if self.context.get('api_interactions'):
+        if self.context.get("api_interactions"):
             print("API INTERACTIONS")
-            success, data = self.context['api_interactions'].validate_handle(attrs.get('handle').lower())
+            success, data = self.context["api_interactions"].validate_handle(
+                attrs.get("handle").lower()
+            )
             print(success, data)
             # {
             #     'message': 'Account found successfully',
@@ -43,20 +48,20 @@ class OfferCredexSerializer(serializers.Serializer):
             # }
             try:
                 if success:
-                    if data.get('message') == "Account found successfully":
-                        data = data.get('data').get('action').get('details')
+                    if data.get("message") == "Account found successfully":
+                        data = data.get("data").get("action").get("details")
                         return {
-                            "issuerAccountID": attrs.get('authorizer_member_id'),
-                            "memberID": attrs.get('issuer_member_id'),
-                            "receiverAccountID": data['accountID'],
-                            "Denomination": attrs.get('currency'),
-                            "InitialAmount": attrs.get('amount'),
-                            "dueDate": convert_timestamp_to_date(attrs.get('dueDate')),
-                            "securedCredex": attrs.get('securedCredex'),
-                            "handle": attrs.get('handle').lower(),
+                            "issuerAccountID": attrs.get("authorizer_member_id"),
+                            "memberID": attrs.get("issuer_member_id"),
+                            "receiverAccountID": data["accountID"],
+                            "Denomination": attrs.get("currency"),
+                            "InitialAmount": attrs.get("amount"),
+                            "dueDate": convert_timestamp_to_date(attrs.get("dueDate")),
+                            "securedCredex": attrs.get("securedCredex"),
+                            "handle": attrs.get("handle").lower(),
                             "full_name": f"{data.get('accountName')}",
                             "OFFERSorREQUESTS": "OFFERS",
-                            "credexType": "PURCHASE"
+                            "credexType": "PURCHASE",
                         }
             except Exception as e:
                 print(e)
diff --git a/invoice.py b/invoice.py
deleted file mode 100644
index e69de29..0000000
diff --git a/projects/getDiff.sh b/projects/getDiff.sh
new file mode 100644
index 0000000..67e9c8d
--- /dev/null
+++ b/projects/getDiff.sh
@@ -0,0 +1,77 @@
+#!/bin/bash
+
+set -e
+
+# Function to echo with timestamp
+log() {
+    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
+}
+
+# Check if two arguments are provided
+if [ $# -ne 2 ]; then
+    log "Usage: $0 <from_branch> <to_branch>"
+    log "Note: This script will automatically use the remote branches."
+    exit 1
+fi
+
+from_branch=$1
+to_branch=$2
+
+# Set output file path to be in same directory as script
+script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+output_file="$script_dir/diff_output.txt"
+
+# Debug: Print the branch names
+log "From branch: $from_branch"
+log "To branch: $to_branch"
+
+# Fetch the latest changes from the remote repository
+log "Fetching latest changes..."
+timeout 60s git fetch origin || { log "Fetch timed out after 60 seconds"; exit 1; }
+log "Fetch completed."
+
+# Debug: List remote branches
+log "Listing remote branches:"
+git --no-pager branch -r
+
+# Get the diff for all files
+log "Getting diff for all changed files..."
+diff_output=$(git --no-pager diff --no-color --ignore-all-space --ignore-blank-lines "origin/$to_branch".."origin/$from_branch")
+
+# Check if there are any differences
+if [ -z "$diff_output" ]; then
+    log "No differences found between $from_branch and $to_branch."
+    summary="No changes detected between $from_branch and $to_branch branches."
+else
+    log "Differences found. Writing to $output_file"
+
+    # Get the list of changed files
+    changed_files=$(git diff --name-only "origin/$to_branch".."origin/$from_branch")
+
+    summary="# Use this command from a codespace environment to create a merge commit with a detailed summary according to best practices from the following diff
+# gh pr create --base \$to_branch --head \$from_branch --title \"Merge \$from_branch into \$to_branch\" --body \"[detailed summary here]\"
+
+Changes detected between $from_branch and $to_branch branches.
+
+Changed files:
+$changed_files
+
+Diff:
+\`\`\`diff
+$diff_output
+\`\`\`"
+
+    # Write the summary to the output file
+    echo "$summary" > "$output_file"
+    log "Diff has been written to $output_file"
+fi
+
+# Output a shorter summary to stdout
+echo "--- BEGIN SUMMARY ---"
+echo "Changes detected between $from_branch and $to_branch branches."
+echo ""
+echo "Changed files:"
+echo "$changed_files"
+echo ""
+echo "Full diff has been written to: $output_file"
+echo "--- END SUMMARY ---"
diff --git a/pyproject.toml b/pyproject.toml
new file mode 100644
index 0000000..99cf93c
--- /dev/null
+++ b/pyproject.toml
@@ -0,0 +1,4 @@
+[tool.black]
+line-length = 88
+target-version = ['py37']
+include = '\.pyi?$'
diff --git a/requirements/base.txt b/requirements/base.txt
index ba46c96..d83edb6 100644
--- a/requirements/base.txt
+++ b/requirements/base.txt
@@ -15,6 +15,7 @@ gunicorn==22.0.0
 redis==5.0.5
 hiredis==2.3.2
 async-timeout==4.0.3
+psycopg2-binary==2.9.9
 
 # Utils
 python-decouple==3.8
diff --git a/terraform/app.tf b/terraform/app.tf
deleted file mode 100644
index b9a448b..0000000
--- a/terraform/app.tf
+++ /dev/null
@@ -1,45 +0,0 @@
-# Infrastructure Module
-module "connectors" {
-  source = "./modules/connectors"
-
-  environment            = var.environment
-  vpc_cidr              = local.current_env.vpc_cidr
-  az_count              = local.current_env.az_count
-  production_domain     = local.current_domain.domain
-  dev_domain_base       = local.current_domain.dev_domain_base
-  environment_subdomains = local.current_domain.environment_subdomains
-  common_tags           = local.common_tags
-}
-
-# Application Module
-module "app" {
-  source = "./modules/app"
-
-  environment                = var.environment
-  aws_region                = local.current_env.aws_region
-  common_tags               = local.common_tags
-
-  # ECS Configuration
-  ecs_task_cpu              = local.current_env.ecs_task.cpu
-  ecs_task_memory           = local.current_env.ecs_task.memory
-
-  # Network Configuration
-  vpc_id                     = module.connectors.vpc_id
-  private_subnet_ids         = module.connectors.private_subnet_ids
-  ecs_tasks_security_group_id = module.connectors.ecs_tasks_security_group_id
-  target_group_arn           = module.connectors.target_group_arn
-
-  # Container Configuration
-  docker_image              = var.docker_image
-  ecs_execution_role_arn    = module.connectors.ecs_execution_role_arn
-  ecs_task_role_arn         = module.connectors.ecs_task_role_arn
-  cloudwatch_log_group_name = module.connectors.cloudwatch_log_group_name
-
-  # Application Environment Variables
-  django_secret            = var.django_secret
-  mycredex_app_url        = var.mycredex_app_url
-  whatsapp_bot_api_key    = var.whatsapp_bot_api_key
-  whatsapp_api_url        = var.whatsapp_api_url
-  whatsapp_access_token   = var.whatsapp_access_token
-  whatsapp_phone_number_id = var.whatsapp_phone_number_id
-}
diff --git a/terraform/connectors.tf b/terraform/connectors.tf
deleted file mode 100644
index e6e7523..0000000
--- a/terraform/connectors.tf
+++ /dev/null
@@ -1,45 +0,0 @@
-module "connectors" {
-  source = "./modules/connectors"
-
-  environment = var.environment
-  aws_region  = local.current_env.aws_region
-
-  # Domain configuration
-  production_domain     = local.env_config.production.domain
-  dev_domain_base      = var.environment == "production" ? null : local.current_env.dev_domain_base
-  environment_subdomains = {
-    for k, v in local.env_config : k => v.subdomain if k != "production"
-  }
-
-  # Network configuration
-  vpc_cidr = local.current_env.vpc_cidr
-
-  # Feature flags - hardcoded since they're always true
-  create_vpc                 = true
-  create_subnets            = true
-  create_igw                = true
-  create_nat                = true
-  create_routes             = true
-  create_sg                 = true
-  create_ecr                = true
-  create_ecs                = true
-  create_logs               = true
-  create_iam                = true
-  create_key_pair           = true
-  create_load_balancer      = true
-  create_target_group       = true
-  create_security_groups    = true
-  create_neo4j_security_group = true
-  create_acm                = true
-
-  # Tags
-  common_tags = local.common_tags
-
-  public_key = tls_private_key.ssh.public_key_openssh
-}
-
-# Generate SSH key
-resource "tls_private_key" "ssh" {
-  algorithm = "RSA"
-  rsa_bits  = 4096
-}
diff --git a/terraform/databases.tf b/terraform/databases.tf
deleted file mode 100644
index 3497ead..0000000
--- a/terraform/databases.tf
+++ /dev/null
@@ -1,45 +0,0 @@
-module "databases" {
-  source = "./modules/databases"
-
-  environment              = var.environment
-  vpc_id                   = module.connectors.vpc_id
-  subnet_ids               = module.connectors.private_subnet_ids
-  neo4j_security_group_id  = module.connectors.neo4j_security_group_id
-  key_pair_name            = module.connectors.key_pair_name
-  neo4j_instance_type      = local.current_env.neo4j.instance_type
-  neo4j_volume_size        = local.current_env.neo4j.volume_size
-  neo4j_enterprise_license = var.neo4j_enterprise_license
-  create_neo4j_instances   = true
-  common_tags             = local.common_tags
-  aws_region              = local.current_env.aws_region
-}
-
-output "neo4j_ledger_instance_id" {
-  value       = module.databases.neo4j_ledger_instance_id
-  description = "The ID of the Neo4j LedgerSpace instance"
-}
-
-output "neo4j_search_instance_id" {
-  value       = module.databases.neo4j_search_instance_id
-  description = "The ID of the Neo4j SearchSpace instance"
-}
-
-output "neo4j_ledger_private_ip" {
-  value       = module.databases.neo4j_ledger_private_ip
-  description = "The private IP address of the Neo4j LedgerSpace instance"
-}
-
-output "neo4j_search_private_ip" {
-  value       = module.databases.neo4j_search_private_ip
-  description = "The private IP address of the Neo4j SearchSpace instance"
-}
-
-output "neo4j_ledger_bolt_endpoint" {
-  value       = module.databases.neo4j_ledger_bolt_endpoint
-  description = "The Bolt endpoint for the Neo4j LedgerSpace instance"
-}
-
-output "neo4j_search_bolt_endpoint" {
-  value       = module.databases.neo4j_search_bolt_endpoint
-  description = "The Bolt endpoint for the Neo4j SearchSpace instance"
-}
diff --git a/terraform/main.tf b/terraform/main.tf
new file mode 100644
index 0000000..fe804b3
--- /dev/null
+++ b/terraform/main.tf
@@ -0,0 +1,481 @@
+# Local variables for environment configuration
+locals {
+  common_tags = {
+    Environment = var.environment
+    ManagedBy   = "terraform"
+    Project     = "vimbiso-pay"
+  }
+
+  # Domain configuration
+  is_production = var.environment == "production"
+  domain = local.is_production ? local.current_env.domain : "${local.current_env.subdomain}.${local.current_env.dev_domain_base}"
+  domain_base = local.is_production ? local.current_env.domain : local.current_env.dev_domain_base
+}
+
+#---------------------------------------------------------------
+# Network Resources
+#---------------------------------------------------------------
+
+# VPC
+resource "aws_vpc" "main" {
+  cidr_block           = local.current_env.vpc_cidr
+  enable_dns_hostnames = true
+  enable_dns_support   = true
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-vpc-${var.environment}"
+  })
+}
+
+# Fetch AZs in the current region
+data "aws_availability_zones" "available" {}
+
+# Private subnets
+resource "aws_subnet" "private" {
+  count             = local.current_env.az_count
+  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 8, count.index)
+  availability_zone = data.aws_availability_zones.available.names[count.index]
+  vpc_id            = aws_vpc.main.id
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-private-${var.environment}-${count.index + 1}"
+  })
+}
+
+# Public subnets
+resource "aws_subnet" "public" {
+  count                   = local.current_env.az_count
+  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 8, local.current_env.az_count + count.index)
+  availability_zone       = data.aws_availability_zones.available.names[count.index]
+  vpc_id                  = aws_vpc.main.id
+  map_public_ip_on_launch = true
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-public-${var.environment}-${count.index + 1}"
+  })
+}
+
+# Internet Gateway
+resource "aws_internet_gateway" "main" {
+  vpc_id = aws_vpc.main.id
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-igw-${var.environment}"
+  })
+}
+
+# Route the public subnet traffic through the IGW
+resource "aws_route" "internet_access" {
+  route_table_id         = aws_vpc.main.main_route_table_id
+  destination_cidr_block = "0.0.0.0/0"
+  gateway_id             = aws_internet_gateway.main.id
+}
+
+# NAT Gateway with Elastic IPs
+resource "aws_eip" "nat" {
+  count      = local.current_env.az_count
+  vpc        = true
+  depends_on = [aws_internet_gateway.main]
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-eip-${var.environment}-${count.index + 1}"
+  })
+}
+
+resource "aws_nat_gateway" "main" {
+  count         = local.current_env.az_count
+  subnet_id     = element(aws_subnet.public[*].id, count.index)
+  allocation_id = element(aws_eip.nat[*].id, count.index)
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-nat-${var.environment}-${count.index + 1}"
+  })
+}
+
+# Private route tables
+resource "aws_route_table" "private" {
+  count  = local.current_env.az_count
+  vpc_id = aws_vpc.main.id
+
+  route {
+    cidr_block     = "0.0.0.0/0"
+    nat_gateway_id = element(aws_nat_gateway.main[*].id, count.index)
+  }
+
+  tags = merge(local.common_tags, {
+    Name = "vimbiso-pay-private-route-${var.environment}-${count.index + 1}"
+  })
+}
+
+resource "aws_route_table_association" "private" {
+  count          = local.current_env.az_count
+  subnet_id      = element(aws_subnet.private[*].id, count.index)
+  route_table_id = element(aws_route_table.private[*].id, count.index)
+}
+
+#---------------------------------------------------------------
+# Security Groups
+#---------------------------------------------------------------
+
+resource "aws_security_group" "alb" {
+  name        = "vimbiso-pay-alb-${var.environment}"
+  description = "Controls access to the ALB"
+  vpc_id      = aws_vpc.main.id
+
+  ingress {
+    protocol    = "tcp"
+    from_port   = 80
+    to_port     = 80
+    cidr_blocks = ["0.0.0.0/0"]
+  }
+
+  ingress {
+    protocol    = "tcp"
+    from_port   = 443
+    to_port     = 443
+    cidr_blocks = ["0.0.0.0/0"]
+  }
+
+  egress {
+    protocol    = "-1"
+    from_port   = 0
+    to_port     = 0
+    cidr_blocks = ["0.0.0.0/0"]
+  }
+
+  tags = local.common_tags
+}
+
+resource "aws_security_group" "ecs_tasks" {
+  name        = "vimbiso-pay-ecs-tasks-${var.environment}"
+  description = "Allow inbound access from the ALB only"
+  vpc_id      = aws_vpc.main.id
+
+  ingress {
+    protocol        = "tcp"
+    from_port       = 8000
+    to_port         = 8000
+    security_groups = [aws_security_group.alb.id]
+  }
+
+  egress {
+    protocol    = "-1"
+    from_port   = 0
+    to_port     = 0
+    cidr_blocks = ["0.0.0.0/0"]
+  }
+
+  tags = local.common_tags
+}
+
+#---------------------------------------------------------------
+# Load Balancer & DNS
+#---------------------------------------------------------------
+
+# ACM Certificate
+resource "aws_acm_certificate" "main" {
+  domain_name       = local.domain
+  validation_method = "DNS"
+
+  tags = local.common_tags
+
+  lifecycle {
+    create_before_destroy = true
+  }
+}
+
+# Route53 Configuration
+data "aws_route53_zone" "domain" {
+  name = local.domain_base
+}
+
+resource "aws_route53_record" "cert_validation" {
+  for_each = {
+    for dvo in aws_acm_certificate.main.domain_validation_options : dvo.domain_name => {
+      name   = dvo.resource_record_name
+      record = dvo.resource_record_value
+      type   = dvo.resource_record_type
+    }
+  }
+
+  allow_overwrite = true
+  name            = each.value.name
+  records         = [each.value.record]
+  ttl             = 60
+  type            = each.value.type
+  zone_id         = data.aws_route53_zone.domain.zone_id
+}
+
+resource "aws_acm_certificate_validation" "main" {
+  certificate_arn         = aws_acm_certificate.main.arn
+  validation_record_fqdns = [for record in aws_route53_record.cert_validation : record.fqdn]
+}
+
+# Application Load Balancer
+resource "aws_lb" "main" {
+  name               = "vimbiso-pay-alb-${var.environment}"
+  internal           = false
+  load_balancer_type = "application"
+  security_groups    = [aws_security_group.alb.id]
+  subnets           = aws_subnet.public[*].id
+
+  tags = local.common_tags
+}
+
+resource "aws_lb_target_group" "app" {
+  name        = "vimbiso-pay-tg-${var.environment}"
+  port        = 8000
+  protocol    = "HTTP"
+  vpc_id      = aws_vpc.main.id
+  target_type = "ip"
+
+  health_check {
+    healthy_threshold   = "2"
+    interval            = "30"
+    protocol            = "HTTP"
+    matcher             = "200"
+    timeout             = "10"
+    path                = "/health/"
+    unhealthy_threshold = "3"
+  }
+
+  tags = local.common_tags
+}
+
+resource "aws_lb_listener" "https" {
+  load_balancer_arn = aws_lb.main.arn
+  port              = "443"
+  protocol          = "HTTPS"
+  ssl_policy        = "ELBSecurityPolicy-2016-08"
+  certificate_arn   = aws_acm_certificate_validation.main.certificate_arn
+
+  default_action {
+    type             = "forward"
+    target_group_arn = aws_lb_target_group.app.arn
+  }
+}
+
+resource "aws_lb_listener" "http" {
+  load_balancer_arn = aws_lb.main.arn
+  port              = "80"
+  protocol          = "HTTP"
+
+  default_action {
+    type = "redirect"
+
+    redirect {
+      port        = "443"
+      protocol    = "HTTPS"
+      status_code = "HTTP_301"
+    }
+  }
+}
+
+#---------------------------------------------------------------
+# Container Registry & IAM
+#---------------------------------------------------------------
+
+# ECR Repository
+resource "aws_ecr_repository" "app" {
+  name = "vimbiso-pay-${var.environment}"
+
+  image_scanning_configuration {
+    scan_on_push = true
+  }
+
+  tags = local.common_tags
+}
+
+# IAM Roles
+resource "aws_iam_role" "ecs_execution_role" {
+  name = "vimbiso-pay-ecs-execution-${var.environment}"
+
+  assume_role_policy = jsonencode({
+    Version = "2012-10-17"
+    Statement = [
+      {
+        Action = "sts:AssumeRole"
+        Effect = "Allow"
+        Principal = {
+          Service = "ecs-tasks.amazonaws.com"
+        }
+      }
+    ]
+  })
+
+  tags = local.common_tags
+}
+
+resource "aws_iam_role_policy_attachment" "ecs_execution_role_policy" {
+  role       = aws_iam_role.ecs_execution_role.name
+  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
+}
+
+resource "aws_iam_role" "ecs_task_role" {
+  name = "vimbiso-pay-ecs-task-${var.environment}"
+
+  assume_role_policy = jsonencode({
+    Version = "2012-10-17"
+    Statement = [
+      {
+        Action = "sts:AssumeRole"
+        Effect = "Allow"
+        Principal = {
+          Service = "ecs-tasks.amazonaws.com"
+        }
+      }
+    ]
+  })
+
+  tags = local.common_tags
+}
+
+#---------------------------------------------------------------
+# ECS Resources
+#---------------------------------------------------------------
+
+# CloudWatch Logs
+resource "aws_cloudwatch_log_group" "app" {
+  name              = "/ecs/vimbiso-pay-${var.environment}"
+  retention_in_days = 30
+
+  tags = local.common_tags
+}
+
+# ECS Cluster
+resource "aws_ecs_cluster" "main" {
+  name = "vimbiso-pay-${var.environment}"
+
+  setting {
+    name  = "containerInsights"
+    value = "enabled"
+  }
+
+  tags = local.common_tags
+}
+
+# ECS Task Definition
+resource "aws_ecs_task_definition" "app" {
+  family                   = "vimbiso-pay-${var.environment}"
+  network_mode             = "awsvpc"
+  requires_compatibilities = ["FARGATE"]
+  cpu                      = local.current_env.ecs_task.cpu
+  memory                   = local.current_env.ecs_task.memory
+  execution_role_arn       = aws_iam_role.ecs_execution_role.arn
+  task_role_arn           = aws_iam_role.ecs_task_role.arn
+
+  container_definitions = jsonencode([
+    {
+      name         = "vimbiso-pay-${var.environment}"
+      image        = var.docker_image
+      essential    = true
+      environment  = [
+        { name = "DJANGO_ENV", value = var.environment },
+        { name = "DJANGO_SECRET", value = var.django_secret },
+        { name = "MYCREDEX_APP_URL", value = var.mycredex_app_url },
+        { name = "WHATSAPP_BOT_API_KEY", value = var.whatsapp_bot_api_key },
+        { name = "WHATSAPP_API_URL", value = var.whatsapp_api_url },
+        { name = "WHATSAPP_ACCESS_TOKEN", value = var.whatsapp_access_token },
+        { name = "WHATSAPP_PHONE_NUMBER_ID", value = var.whatsapp_phone_number_id }
+      ]
+      portMappings = [
+        {
+          containerPort = 8000
+          hostPort      = 8000
+          protocol      = "tcp"
+        }
+      ]
+      logConfiguration = {
+        logDriver = "awslogs"
+        options = {
+          awslogs-group         = aws_cloudwatch_log_group.app.name
+          awslogs-region        = local.current_env.aws_region
+          awslogs-stream-prefix = "ecs"
+        }
+      }
+      healthCheck = {
+        command     = ["CMD-SHELL", "curl -f http://localhost:8000/health/ || exit 1"]
+        interval    = 30
+        timeout     = 5
+        retries     = 3
+        startPeriod = 60
+      }
+    }
+  ])
+
+  tags = local.common_tags
+}
+
+# ECS Service
+resource "aws_ecs_service" "app" {
+  name                               = "vimbiso-pay-service-${var.environment}"
+  cluster                           = aws_ecs_cluster.main.id
+  task_definition                   = aws_ecs_task_definition.app.arn
+  desired_count                     = 2
+  deployment_minimum_healthy_percent = 50
+  deployment_maximum_percent        = 200
+  launch_type                       = "FARGATE"
+  scheduling_strategy               = "REPLICA"
+  platform_version                  = "LATEST"
+
+  network_configuration {
+    security_groups  = [aws_security_group.ecs_tasks.id]
+    subnets         = aws_subnet.private[*].id
+    assign_public_ip = false
+  }
+
+  load_balancer {
+    target_group_arn = aws_lb_target_group.app.arn
+    container_name   = "vimbiso-pay-${var.environment}"
+    container_port   = 8000
+  }
+
+  deployment_controller {
+    type = "ECS"
+  }
+
+  lifecycle {
+    ignore_changes = [task_definition, desired_count]
+  }
+
+  tags = local.common_tags
+}
+
+# Auto Scaling
+resource "aws_appautoscaling_target" "app" {
+  max_capacity       = 4
+  min_capacity       = 2
+  resource_id        = "service/${aws_ecs_cluster.main.name}/${aws_ecs_service.app.name}"
+  scalable_dimension = "ecs:service:DesiredCount"
+  service_namespace  = "ecs"
+}
+
+resource "aws_appautoscaling_policy" "cpu" {
+  name               = "vimbiso-pay-cpu-autoscaling-${var.environment}"
+  policy_type        = "TargetTrackingScaling"
+  resource_id        = aws_appautoscaling_target.app.resource_id
+  scalable_dimension = aws_appautoscaling_target.app.scalable_dimension
+  service_namespace  = aws_appautoscaling_target.app.service_namespace
+
+  target_tracking_scaling_policy_configuration {
+    predefined_metric_specification {
+      predefined_metric_type = "ECSServiceAverageCPUUtilization"
+    }
+    target_value = 80
+  }
+}
+
+resource "aws_appautoscaling_policy" "memory" {
+  name               = "vimbiso-pay-memory-autoscaling-${var.environment}"
+  policy_type        = "TargetTrackingScaling"
+  resource_id        = aws_appautoscaling_target.app.resource_id
+  scalable_dimension = aws_appautoscaling_target.app.scalable_dimension
+  service_namespace  = aws_appautoscaling_target.app.service_namespace
+
+  target_tracking_scaling_policy_configuration {
+    predefined_metric_specification {
+      predefined_metric_type = "ECSServiceAverageMemoryUtilization"
+    }
+    target_value = 80
+  }
+}
diff --git a/terraform/modules/app/main.tf b/terraform/modules/app/main.tf
deleted file mode 100644
index 5290129..0000000
--- a/terraform/modules/app/main.tf
+++ /dev/null
@@ -1,139 +0,0 @@
-# ECS Cluster
-resource "aws_ecs_cluster" "main" {
-  name = "vimbiso-pay-cluster-${var.environment}"
-
-  setting {
-    name  = "containerInsights"
-    value = "enabled"
-  }
-
-  tags = var.common_tags
-}
-
-# ECS Task Definition
-resource "aws_ecs_task_definition" "app" {
-  family                   = "vimbiso-pay-${var.environment}"
-  network_mode             = "awsvpc"
-  requires_compatibilities = ["FARGATE"]
-  cpu                      = var.ecs_task_cpu
-  memory                   = var.ecs_task_memory
-  execution_role_arn       = var.ecs_execution_role_arn
-  task_role_arn           = var.ecs_task_role_arn
-
-  container_definitions = jsonencode([
-    {
-      name         = "vimbiso-pay-${var.environment}"
-      image        = var.docker_image
-      essential    = true
-      environment  = [
-        { name = "DJANGO_ENV", value = var.environment },
-        { name = "DJANGO_SECRET", value = var.django_secret },
-        { name = "MYCREDEX_APP_URL", value = var.mycredex_app_url },
-        { name = "WHATSAPP_BOT_API_KEY", value = var.whatsapp_bot_api_key },
-        { name = "WHATSAPP_API_URL", value = var.whatsapp_api_url },
-        { name = "WHATSAPP_ACCESS_TOKEN", value = var.whatsapp_access_token },
-        { name = "WHATSAPP_PHONE_NUMBER_ID", value = var.whatsapp_phone_number_id }
-      ]
-      portMappings = [
-        {
-          containerPort = 8000
-          hostPort      = 8000
-          protocol      = "tcp"
-        }
-      ]
-      logConfiguration = {
-        logDriver = "awslogs"
-        options = {
-          awslogs-group         = var.cloudwatch_log_group_name
-          awslogs-region        = var.aws_region
-          awslogs-stream-prefix = "ecs"
-        }
-      }
-      healthCheck = {
-        command     = ["CMD-SHELL", "curl -f http://localhost:8000/health/ || exit 1"]
-        interval    = 30
-        timeout     = 5
-        retries     = 3
-        startPeriod = 60
-      }
-    }
-  ])
-
-  tags = var.common_tags
-}
-
-# ECS Service
-resource "aws_ecs_service" "app" {
-  name                               = "vimbiso-pay-service-${var.environment}"
-  cluster                           = aws_ecs_cluster.main.id
-  task_definition                   = aws_ecs_task_definition.app.arn
-  desired_count                     = 2
-  deployment_minimum_healthy_percent = 50
-  deployment_maximum_percent        = 200
-  launch_type                       = "FARGATE"
-  scheduling_strategy               = "REPLICA"
-  platform_version                  = "LATEST"
-
-  network_configuration {
-    security_groups  = [var.ecs_tasks_security_group_id]
-    subnets         = var.private_subnet_ids
-    assign_public_ip = false
-  }
-
-  load_balancer {
-    target_group_arn = var.target_group_arn
-    container_name   = "vimbiso-pay-${var.environment}"
-    container_port   = 8000
-  }
-
-  deployment_controller {
-    type = "ECS"
-  }
-
-  lifecycle {
-    ignore_changes = [task_definition, desired_count]
-  }
-
-  tags = var.common_tags
-}
-
-# Auto Scaling
-resource "aws_appautoscaling_target" "app" {
-  max_capacity       = 4
-  min_capacity       = 2
-  resource_id        = "service/${aws_ecs_cluster.main.name}/${aws_ecs_service.app.name}"
-  scalable_dimension = "ecs:service:DesiredCount"
-  service_namespace  = "ecs"
-}
-
-# CPU Auto Scaling
-resource "aws_appautoscaling_policy" "cpu" {
-  name               = "vimbiso-pay-cpu-autoscaling-${var.environment}"
-  policy_type        = "TargetTrackingScaling"
-  resource_id        = aws_appautoscaling_target.app.resource_id
-  scalable_dimension = aws_appautoscaling_target.app.scalable_dimension
-  service_namespace  = aws_appautoscaling_target.app.service_namespace
-
-  target_tracking_scaling_policy_configuration {
-    predefined_metric_specification {
-      predefined_metric_type = "ECSServiceAverageCPUUtilization"
-    }
-    target_value = 80
-  }
-}
-
-# Memory Auto Scaling
-resource "aws_appautoscaling_policy" "memory" {
-  name               = "vimbiso-pay-memory-autoscaling-${var.environment}"
-  policy_type        = "TargetTrackingScaling"
-  resource_id        = aws_appautoscaling_target.app.resource_id
-  scalable_dimension = aws_appautoscaling_target.app.scalable_dimension
-  service_namespace  = aws_appautoscaling_target.app.service_namespace
-
-  target_tracking_scaling_policy_configuration {
-    predefined_metric_specification {
-      predefined_metric_type = "ECSServiceAverageMemoryUtilization"
-    }
-    target_value = 80
-  }
-}
diff --git a/terraform/modules/app/outputs.tf b/terraform/modules/app/outputs.tf
deleted file mode 100644
index b2bf1ff..0000000
--- a/terraform/modules/app/outputs.tf
+++ /dev/null
@@ -1,43 +0,0 @@
-# ECS Cluster
-output "ecs_cluster_arn" {
-  description = "ARN of the ECS cluster"
-  value       = aws_ecs_cluster.main.arn
-}
-
-output "ecs_cluster_name" {
-  description = "Name of the ECS cluster"
-  value       = aws_ecs_cluster.main.name
-}
-
-# ECS Task Definition
-output "ecs_task_definition_arn" {
-  description = "ARN of the ECS task definition"
-  value       = aws_ecs_task_definition.app.arn
-}
-
-output "ecs_task_definition_family" {
-  description = "Family of the ECS task definition"
-  value       = aws_ecs_task_definition.app.family
-}
-
-# ECS Service
-output "ecs_service_name" {
-  description = "Name of the ECS service"
-  value       = aws_ecs_service.app.name
-}
-
-output "ecs_service_id" {
-  description = "ID of the ECS service"
-  value       = aws_ecs_service.app.id
-}
-
-# Auto Scaling
-output "autoscaling_target_min_capacity" {
-  description = "Minimum capacity of the auto scaling target"
-  value       = aws_appautoscaling_target.app.min_capacity
-}
-
-output "autoscaling_target_max_capacity" {
-  description = "Maximum capacity of the auto scaling target"
-  value       = aws_appautoscaling_target.app.max_capacity
-}
diff --git a/terraform/modules/app/variables.tf b/terraform/modules/app/variables.tf
deleted file mode 100644
index 57672f6..0000000
--- a/terraform/modules/app/variables.tf
+++ /dev/null
@@ -1,102 +0,0 @@
-variable "environment" {
-  description = "The deployment environment (staging, production)"
-  type        = string
-}
-
-variable "aws_region" {
-  description = "The AWS region to deploy to"
-  type        = string
-}
-
-variable "common_tags" {
-  description = "Common tags to apply to all resources"
-  type        = map(string)
-}
-
-# ECS Configuration
-variable "ecs_task_cpu" {
-  description = "CPU units for the ECS task (1024 = 1 vCPU)"
-  type        = string
-}
-
-variable "ecs_task_memory" {
-  description = "Memory for the ECS task in MiB"
-  type        = string
-}
-
-# Network Configuration
-variable "vpc_id" {
-  description = "ID of the VPC"
-  type        = string
-}
-
-variable "private_subnet_ids" {
-  description = "List of private subnet IDs"
-  type        = list(string)
-}
-
-variable "ecs_tasks_security_group_id" {
-  description = "Security group ID for ECS tasks"
-  type        = string
-}
-
-variable "target_group_arn" {
-  description = "ARN of the target group"
-  type        = string
-}
-
-# Container Configuration
-variable "docker_image" {
-  description = "Docker image to deploy"
-  type        = string
-}
-
-variable "ecs_execution_role_arn" {
-  description = "ARN of the ECS execution role"
-  type        = string
-}
-
-variable "ecs_task_role_arn" {
-  description = "ARN of the ECS task role"
-  type        = string
-}
-
-variable "cloudwatch_log_group_name" {
-  description = "Name of the CloudWatch log group"
-  type        = string
-}
-
-# Application Environment Variables
-variable "django_secret" {
-  description = "Django secret key"
-  type        = string
-  sensitive   = true
-}
-
-variable "mycredex_app_url" {
-  description = "URL for the Credex Core API"
-  type        = string
-}
-
-variable "whatsapp_bot_api_key" {
-  description = "API key for WhatsApp bot"
-  type        = string
-  sensitive   = true
-}
-
-variable "whatsapp_api_url" {
-  description = "WhatsApp API URL"
-  type        = string
-}
-
-variable "whatsapp_access_token" {
-  description = "WhatsApp access token"
-  type        = string
-  sensitive   = true
-}
-
-variable "whatsapp_phone_number_id" {
-  description = "WhatsApp phone number ID"
-  type        = string
-  sensitive   = true
-}
diff --git a/terraform/modules/connectors/main.tf b/terraform/modules/connectors/main.tf
deleted file mode 100644
index 2fba864..0000000
--- a/terraform/modules/connectors/main.tf
+++ /dev/null
@@ -1,393 +0,0 @@
-# Add us-east-1 provider for ACM certificates
-provider "aws" {
-  alias  = "us_east_1"
-  region = "us-east-1"
-}
-
-# Local variables
-locals {
-  common_tags = {
-    Environment = var.environment
-    Project     = "Vimbiso Pay"
-    ManagedBy   = "Terraform"
-  }
-  
-  # Domain logic with validation
-  is_production = var.environment == "production"
-  
-  # Domain logic
-  domain = local.is_production ? var.production_domain : "${var.environment_subdomains[var.environment]}.${var.dev_domain_base}"
-  domain_base = local.is_production ? var.production_domain : var.dev_domain_base
-}
-
-# VPC
-resource "aws_vpc" "main" {
-  cidr_block           = var.vpc_cidr
-  enable_dns_hostnames = true
-  enable_dns_support   = true
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-vpc-${var.environment}"
-  })
-}
-
-# Fetch AZs in the current region
-data "aws_availability_zones" "available" {}
-
-# Create private subnets, each in a different AZ
-resource "aws_subnet" "private" {
-  count             = var.az_count
-  cidr_block        = cidrsubnet(aws_vpc.main.cidr_block, 8, count.index)
-  availability_zone = data.aws_availability_zones.available.names[count.index]
-  vpc_id            = aws_vpc.main.id
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-private-subnet-${var.environment}-${count.index + 1}"
-  })
-}
-
-# Create public subnets, each in a different AZ
-resource "aws_subnet" "public" {
-  count                   = var.az_count
-  cidr_block              = cidrsubnet(aws_vpc.main.cidr_block, 8, var.az_count + count.index)
-  availability_zone       = data.aws_availability_zones.available.names[count.index]
-  vpc_id                  = aws_vpc.main.id
-  map_public_ip_on_launch = true
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-public-subnet-${var.environment}-${count.index + 1}"
-  })
-}
-
-# Internet Gateway for the public subnet
-resource "aws_internet_gateway" "main" {
-  vpc_id = aws_vpc.main.id
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-igw-${var.environment}"
-  })
-}
-
-# Route the public subnet traffic through the IGW
-resource "aws_route" "internet_access" {
-  route_table_id         = aws_vpc.main.main_route_table_id
-  destination_cidr_block = "0.0.0.0/0"
-  gateway_id             = aws_internet_gateway.main.id
-}
-
-# Create a NAT gateway with an Elastic IP for each private subnet
-resource "aws_eip" "nat" {
-  count      = var.az_count
-  vpc        = true
-  depends_on = [aws_internet_gateway.main]
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-eip-${var.environment}-${count.index + 1}"
-  })
-}
-
-resource "aws_nat_gateway" "main" {
-  count         = var.az_count
-  subnet_id     = element(aws_subnet.public[*].id, count.index)
-  allocation_id = element(aws_eip.nat[*].id, count.index)
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-nat-${var.environment}-${count.index + 1}"
-  })
-}
-
-# Create a new route table for the private subnets
-resource "aws_route_table" "private" {
-  count  = var.az_count
-  vpc_id = aws_vpc.main.id
-
-  route {
-    cidr_block     = "0.0.0.0/0"
-    nat_gateway_id = element(aws_nat_gateway.main[*].id, count.index)
-  }
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-private-route-table-${var.environment}-${count.index + 1}"
-  })
-}
-
-# Associate the private subnets with the appropriate route tables
-resource "aws_route_table_association" "private" {
-  count          = var.az_count
-  subnet_id      = element(aws_subnet.private[*].id, count.index)
-  route_table_id = element(aws_route_table.private[*].id, count.index)
-}
-
-# ALB security group
-resource "aws_security_group" "alb" {
-  name        = "vimbiso-pay-alb-sg-${var.environment}"
-  description = "Controls access to the ALB"
-  vpc_id      = aws_vpc.main.id
-
-  ingress {
-    protocol    = "tcp"
-    from_port   = 80
-    to_port     = 80
-    cidr_blocks = ["0.0.0.0/0"]
-    description = "Allow HTTP inbound traffic"
-  }
-
-  ingress {
-    protocol    = "tcp"
-    from_port   = 443
-    to_port     = 443
-    cidr_blocks = ["0.0.0.0/0"]
-    description = "Allow HTTPS inbound traffic"
-  }
-
-  egress {
-    protocol    = "-1"
-    from_port   = 0
-    to_port     = 0
-    cidr_blocks = ["0.0.0.0/0"]
-    description = "Allow all outbound traffic"
-  }
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-alb-sg-${var.environment}"
-  })
-}
-
-# ECS tasks security group
-resource "aws_security_group" "ecs_tasks" {
-  name        = "vimbiso-pay-ecs-tasks-sg-${var.environment}"
-  description = "Allow inbound access from the ALB only"
-  vpc_id      = aws_vpc.main.id
-
-  ingress {
-    protocol        = "tcp"
-    from_port       = 8000
-    to_port         = 8000
-    security_groups = [aws_security_group.alb.id]
-    description     = "Allow inbound traffic from ALB"
-  }
-
-  egress {
-    protocol    = "-1"
-    from_port   = 0
-    to_port     = 0
-    cidr_blocks = ["0.0.0.0/0"]
-    description = "Allow all outbound traffic"
-  }
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-ecs-tasks-sg-${var.environment}"
-  })
-}
-
-# ACM Certificate for ALB
-resource "aws_acm_certificate" "cert" {
-  domain_name               = local.domain
-  validation_method         = "DNS"
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-cert-${var.environment}"
-  })
-
-  lifecycle {
-    create_before_destroy = true
-  }
-}
-
-# Get the hosted zone for the domain
-data "aws_route53_zone" "domain" {
-  name = local.domain_base
-}
-
-# Create DNS records for certificate validation
-resource "aws_route53_record" "cert_validation" {
-  for_each = {
-    for dvo in aws_acm_certificate.cert.domain_validation_options : dvo.domain_name => {
-      name   = dvo.resource_record_name
-      record = dvo.resource_record_value
-      type   = dvo.resource_record_type
-    }
-  }
-
-  allow_overwrite = true
-  name            = each.value.name
-  records         = [each.value.record]
-  ttl             = 60
-  type            = each.value.type
-  zone_id         = data.aws_route53_zone.domain.zone_id
-}
-
-# Certificate validation
-resource "aws_acm_certificate_validation" "cert" {
-  certificate_arn         = aws_acm_certificate.cert.arn
-  validation_record_fqdns = [for record in aws_route53_record.cert_validation : record.fqdn]
-}
-
-# Application Load Balancer (ALB)
-resource "aws_lb" "main" {
-  name               = "vimbiso-pay-alb-${var.environment}"
-  internal           = false
-  load_balancer_type = "application"
-  security_groups    = [aws_security_group.alb.id]
-  subnets            = aws_subnet.public[*].id
-
-  tags = local.common_tags
-}
-
-# Target Group
-resource "aws_lb_target_group" "app" {
-  name        = "vimbiso-pay-tg-${var.environment}"
-  port        = 8000
-  protocol    = "HTTP"
-  vpc_id      = aws_vpc.main.id
-  target_type = "ip"
-
-  health_check {
-    healthy_threshold   = "2"
-    interval            = "30"
-    protocol            = "HTTP"
-    matcher             = "200"
-    timeout             = "10"
-    path                = "/health/"
-    unhealthy_threshold = "3"
-  }
-
-  tags = local.common_tags
-}
-
-# Create Route53 record
-resource "aws_route53_record" "app" {
-  zone_id = data.aws_route53_zone.domain.zone_id
-  name    = local.domain
-  type    = "A"
-
-  alias {
-    name                   = aws_lb.main.dns_name
-    zone_id                = aws_lb.main.zone_id
-    evaluate_target_health = true
-  }
-}
-
-# ALB Listener
-resource "aws_lb_listener" "app" {
-  load_balancer_arn = aws_lb.main.arn
-  port              = "443"
-  protocol          = "HTTPS"
-  ssl_policy        = "ELBSecurityPolicy-2016-08"
-  certificate_arn   = aws_acm_certificate_validation.cert.certificate_arn
-
-  default_action {
-    type             = "forward"
-    target_group_arn = aws_lb_target_group.app.arn
-  }
-}
-
-# HTTP to HTTPS redirect
-resource "aws_lb_listener" "http" {
-  load_balancer_arn = aws_lb.main.arn
-  port              = "80"
-  protocol          = "HTTP"
-
-  default_action {
-    type = "redirect"
-
-    redirect {
-      port        = "443"
-      protocol    = "HTTPS"
-      status_code = "HTTP_301"
-    }
-  }
-}
-
-# ECR Repository
-resource "aws_ecr_repository" "app" {
-  name = "vimbiso-pay-${var.environment}"
-  
-  image_scanning_configuration {
-    scan_on_push = true
-  }
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-ecr-${var.environment}"
-  })
-}
-
-# ECS execution role
-resource "aws_iam_role" "ecs_execution_role" {
-  name = "vimbiso-pay-ecs-execution-role-${var.environment}"
-
-  assume_role_policy = jsonencode({
-    Version = "2012-10-17"
-    Statement = [
-      {
-        Action = "sts:AssumeRole"
-        Effect = "Allow"
-        Principal = {
-          Service = "ecs-tasks.amazonaws.com"
-        }
-      }
-    ]
-  })
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-ecs-execution-role-${var.environment}"
-  })
-}
-
-resource "aws_iam_role_policy_attachment" "ecs_execution_role_policy" {
-  role       = aws_iam_role.ecs_execution_role.name
-  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
-}
-
-# ECS task role
-resource "aws_iam_role" "ecs_task_role" {
-  name = "vimbiso-pay-ecs-task-role-${var.environment}"
-
-  assume_role_policy = jsonencode({
-    Version = "2012-10-17"
-    Statement = [
-      {
-        Action = "sts:AssumeRole"
-        Effect = "Allow"
-        Principal = {
-          Service = "ecs-tasks.amazonaws.com"
-        }
-      }
-    ]
-  })
-
-  tags = merge(local.common_tags, {
-    Name = "vimbiso-pay-ecs-task-role-${var.environment}"
-  })
-}
-
-# Add CloudWatch Logs permissions to ECS task role
-resource "aws_iam_role_policy" "ecs_task_role_policy" {
-  name = "vimbiso-pay-ecs-task-role-policy-${var.environment}"
-  role = aws_iam_role.ecs_task_role.id
-
-  policy = jsonencode({
-    Version = "2012-10-17"
-    Statement = [
-      {
-        Effect = "Allow"
-        Action = [
-          "logs:CreateLogStream",
-          "logs:PutLogEvents",
-          "logs:DescribeLogStreams"
-        ]
-        Resource = "${aws_cloudwatch_log_group.ecs_logs.arn}:*"
-      }
-    ]
-  })
-}
-
-# CloudWatch log group
-resource "aws_cloudwatch_log_group" "ecs_logs" {
-  name              = "/ecs/vimbiso-pay-${var.environment}"
-  retention_in_days = 30
-
-  tags = merge(local.common_tags, {
-    Name = "/ecs/vimbiso-pay-${var.environment}"
-  })
-}
diff --git a/terraform/modules/connectors/outputs.tf b/terraform/modules/connectors/outputs.tf
deleted file mode 100644
index 172c8cc..0000000
--- a/terraform/modules/connectors/outputs.tf
+++ /dev/null
@@ -1,66 +0,0 @@
-# VPC
-output "vpc_id" {
-  description = "The ID of the VPC"
-  value       = aws_vpc.main.id
-}
-
-output "private_subnet_ids" {
-  description = "List of private subnet IDs"
-  value       = aws_subnet.private[*].id
-}
-
-output "public_subnet_ids" {
-  description = "List of public subnet IDs"
-  value       = aws_subnet.public[*].id
-}
-
-# Security Groups
-output "alb_security_group_id" {
-  description = "Security group ID for the ALB"
-  value       = aws_security_group.alb.id
-}
-
-output "ecs_tasks_security_group_id" {
-  description = "Security group ID for ECS tasks"
-  value       = aws_security_group.ecs_tasks.id
-}
-
-# Load Balancer
-output "target_group_arn" {
-  description = "ARN of the target group"
-  value       = aws_lb_target_group.app.arn
-}
-
-output "alb_listener" {
-  description = "ARN of the ALB listener"
-  value       = aws_lb_listener.app.arn
-}
-
-# ECR
-output "ecr_repository_url" {
-  description = "URL of the ECR repository"
-  value       = aws_ecr_repository.app.repository_url
-}
-
-# IAM Roles
-output "ecs_execution_role_arn" {
-  description = "ARN of the ECS execution role"
-  value       = aws_iam_role.ecs_execution_role.arn
-}
-
-output "ecs_task_role_arn" {
-  description = "ARN of the ECS task role"
-  value       = aws_iam_role.ecs_task_role.arn
-}
-
-# CloudWatch
-output "cloudwatch_log_group_name" {
-  description = "Name of the CloudWatch log group"
-  value       = aws_cloudwatch_log_group.ecs_logs.name
-}
-
-# Domain
-output "domain" {
-  description = "The domain name for the environment"
-  value       = local.domain
-}
diff --git a/terraform/modules/connectors/variables.tf b/terraform/modules/connectors/variables.tf
deleted file mode 100644
index 7ab2f15..0000000
--- a/terraform/modules/connectors/variables.tf
+++ /dev/null
@@ -1,42 +0,0 @@
-variable "environment" {
-  description = "The deployment environment (staging, production)"
-  type        = string
-
-  validation {
-    condition     = contains(["production", "staging"], var.environment)
-    error_message = "Environment must be one of: production, staging"
-  }
-}
-
-variable "vpc_cidr" {
-  description = "CIDR block for VPC"
-  type        = string
-}
-
-variable "az_count" {
-  description = "Number of AZs to use"
-  type        = number
-  default     = 2
-}
-
-variable "production_domain" {
-  description = "The domain name for production environment"
-  type        = string
-}
-
-variable "dev_domain_base" {
-  description = "The base domain for non-production environments"
-  type        = string
-}
-
-variable "environment_subdomains" {
-  description = "Map of environment names to their subdomains"
-  type        = map(string)
-}
-
-# Optional variables with defaults
-variable "common_tags" {
-  description = "Common tags to apply to all resources"
-  type        = map(string)
-  default     = {}
-}
diff --git a/terraform/outputs.tf b/terraform/outputs.tf
index 173783a..08d62f2 100644
--- a/terraform/outputs.tf
+++ b/terraform/outputs.tf
@@ -1,59 +1,81 @@
-# Infrastructure Outputs
+# Network Outputs
 output "vpc_id" {
   description = "The ID of the VPC"
-  value       = module.connectors.vpc_id
+  value       = aws_vpc.main.id
 }
 
 output "private_subnet_ids" {
-  description = "The IDs of the private subnets"
-  value       = module.connectors.private_subnet_ids
+  description = "List of private subnet IDs"
+  value       = aws_subnet.private[*].id
 }
 
 output "public_subnet_ids" {
-  description = "The IDs of the public subnets"
-  value       = module.connectors.public_subnet_ids
+  description = "List of public subnet IDs"
+  value       = aws_subnet.public[*].id
 }
 
-output "ecr_repository_url" {
-  description = "The URL of the ECR repository"
-  value       = module.connectors.ecr_repository_url
+# Security Groups
+output "alb_security_group_id" {
+  description = "Security group ID for the ALB"
+  value       = aws_security_group.alb.id
+}
+
+output "ecs_tasks_security_group_id" {
+  description = "Security group ID for ECS tasks"
+  value       = aws_security_group.ecs_tasks.id
+}
+
+# Load Balancer
+output "alb_dns_name" {
+  description = "DNS name of the Application Load Balancer"
+  value       = aws_lb.main.dns_name
+}
+
+output "target_group_arn" {
+  description = "ARN of the target group"
+  value       = aws_lb_target_group.app.arn
 }
 
+# Domain
 output "domain" {
   description = "The domain name for the environment"
-  value       = module.connectors.domain
+  value       = local.domain
 }
 
-# Application Outputs
+# Container Registry
+output "ecr_repository_url" {
+  description = "URL of the ECR repository"
+  value       = aws_ecr_repository.app.repository_url
+}
+
+# ECS Resources
 output "ecs_cluster_arn" {
-  description = "The ARN of the ECS cluster"
-  value       = module.app.ecs_cluster_arn
+  description = "ARN of the ECS cluster"
+  value       = aws_ecs_cluster.main.arn
 }
 
 output "ecs_cluster_name" {
-  description = "The name of the ECS cluster"
-  value       = module.app.ecs_cluster_name
+  description = "Name of the ECS cluster"
+  value       = aws_ecs_cluster.main.name
 }
 
 output "ecs_service_name" {
-  description = "The name of the ECS service"
-  value       = module.app.ecs_service_name
-}
-
-output "ecs_service_id" {
-  description = "The ID of the ECS service"
-  value       = module.app.ecs_service_id
+  description = "Name of the ECS service"
+  value       = aws_ecs_service.app.name
 }
 
 output "ecs_task_definition_arn" {
-  description = "The ARN of the ECS task definition"
-  value       = module.app.ecs_task_definition_arn
+  description = "ARN of the ECS task definition"
+  value       = aws_ecs_task_definition.app.arn
 }
 
-output "autoscaling_config" {
-  description = "Auto scaling configuration"
-  value = {
-    min_capacity = module.app.autoscaling_target_min_capacity
-    max_capacity = module.app.autoscaling_target_max_capacity
+# Auto Scaling
+output "autoscaling_target_min_capacity" {
+  description = "Minimum capacity of the auto scaling target"
+  value       = aws_appautoscaling_target.app.min_capacity
 }
+
+output "autoscaling_target_max_capacity" {
+  description = "Maximum capacity of the auto scaling target"
+  value       = aws_appautoscaling_target.app.max_capacity
 }
diff --git a/terraform/variables.tf b/terraform/variables.tf
index cf8b588..47b31c4 100644
--- a/terraform/variables.tf
+++ b/terraform/variables.tf
@@ -1,4 +1,4 @@
-# Required variables
+# Required Environment Variables
 variable "environment" {
   description = "The deployment environment (staging, production)"
   type        = string
@@ -9,6 +9,7 @@ variable "environment" {
   }
 }
 
+# Application Configuration
 variable "docker_image" {
   description = "The full Docker image to deploy (including repository and tag)"
   type        = string
@@ -27,7 +28,7 @@ variable "mycredex_app_url" {
 }
 
 # WhatsApp Integration Variables
-variable "whatsapp_bot_api_key" {
+variable "client_api_key" {
   description = "API key for WhatsApp bot"
   type        = string
   sensitive   = true
@@ -49,3 +50,10 @@ variable "whatsapp_phone_number_id" {
   type        = string
   sensitive   = true
 }
+
+# Neo4j License
+variable "neo4j_enterprise_license" {
+  description = "Neo4j Enterprise Edition license key"
+  type        = string
+  sensitive   = true
+}
```

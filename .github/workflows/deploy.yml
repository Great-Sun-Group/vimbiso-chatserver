name: Deploy VimbisoPay

on:
  push:
    branches:
      - stage
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/prod' || github.ref == 'refs/heads/stage'
    environment: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
    timeout-minutes: 30

    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
      BUILD_TARGET: production
      DOMAIN: ${{ github.ref == 'refs/heads/prod' && 'whatsapp.vimbisopay.africa' || 'stage.whatsapp.vimbisopay.africa' }}
      # Common Terraform variables
      TF_VAR_environment: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
      TF_VAR_docker_image: "dummy-image:latest"
      TF_VAR_django_secret: "dummy-secret"
      TF_VAR_mycredex_app_url: "https://dummy-url"
      TF_VAR_client_api_key: "dummy-key"
      TF_VAR_whatsapp_api_url: "https://dummy-url"
      TF_VAR_whatsapp_access_token: "dummy-token"
      TF_VAR_whatsapp_phone_number_id: "dummy-id"
      TF_VAR_whatsapp_business_id: "dummy-id"
      TF_VAR_whatsapp_registration_flow_id: "dummy-id"
      TF_VAR_whatsapp_company_registration_flow_id: "dummy-id"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: af-south-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Initialize Terraform Backend
        id: init-backend
        run: |
          echo "Current environment: ${ENVIRONMENT}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="vimbiso-pay-terraform-state-${ENVIRONMENT}-${AWS_ACCOUNT_ID}"
          TABLE_NAME="vimbiso-pay-terraform-state-lock-${ENVIRONMENT}-${AWS_ACCOUNT_ID}"

          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            aws s3api create-bucket --bucket "$BUCKET_NAME" --create-bucket-configuration LocationConstraint=af-south-1
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
          fi

          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" >/dev/null 2>&1; then
            aws dynamodb create-table --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --tags Key=Environment,Value=${ENVIRONMENT} Key=ManagedBy,Value=terraform
          fi

          cd terraform
          terraform init \
            -backend-config="bucket=${BUCKET_NAME}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=af-south-1" \
            -backend-config="dynamodb_table=${TABLE_NAME}"

          echo "dynamodb_table=${TABLE_NAME}" >> $GITHUB_OUTPUT

      - name: Clear Stale Locks
        env:
          DYNAMODB_TABLE: ${{ steps.init-backend.outputs.dynamodb_table }}
        run: |
          cd terraform
          LOCKS_JSON=$(aws dynamodb scan --table-name "$DYNAMODB_TABLE" --output json)
          if [ ! -z "$LOCKS_JSON" ] && [ "$LOCKS_JSON" != "null" ]; then
            echo "$LOCKS_JSON" | jq -r '.Items[] | select(.LockID != null) | .LockID.S' | while read -r LOCK_ID; do
              if [ ! -z "$LOCK_ID" ]; then
                aws dynamodb delete-item \
                  --table-name "$DYNAMODB_TABLE" \
                  --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
                  --return-values ALL_OLD
              fi
            done
          fi

      - name: Deploy Infrastructure
        run: |
          cd terraform
          # Deploy all infrastructure except ECS (which needs the latest image)
          terraform plan -input=false -lock-timeout=20m \
            -target=module.networking \
            -target=module.route53_cert \
            -target=module.loadbalancer \
            -target=module.route53_dns \
            -target=module.iam \
            -target=module.ecr \
            -target=module.efs \
            -out=infra.tfplan

          terraform apply -input=false -lock-timeout=20m infra.tfplan

          # Display NS records for reference
          echo "NS records for ${DOMAIN}:"
          terraform output -json route53_nameservers | jq -r '.[]' | sed 's/^/- /'

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: vimbiso-pay-${{ env.ENVIRONMENT }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build --no-cache --target $BUILD_TARGET \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy Application
        env:
          TF_VAR_docker_image: ${{ env.IMAGE }}
          TF_VAR_django_secret: ${{ secrets.DJANGO_SECRET }}
          TF_VAR_mycredex_app_url: ${{ secrets.MYCREDEX_APP_URL }}
          TF_VAR_client_api_key: ${{ secrets.CLIENT_API_KEY }}
          TF_VAR_whatsapp_api_url: ${{ secrets.WHATSAPP_API_URL }}
          TF_VAR_whatsapp_access_token: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
          TF_VAR_whatsapp_phone_number_id: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
          TF_VAR_whatsapp_business_id: ${{ secrets.WHATSAPP_BUSINESS_ID }}
          TF_VAR_whatsapp_registration_flow_id: ${{ secrets.WHATSAPP_REGISTRATION_FLOW_ID }}
          TF_VAR_whatsapp_company_registration_flow_id: ${{ secrets.WHATSAPP_COMPANY_REGISTRATION_FLOW_ID }}
        run: |
          cd terraform
          # Deploy only ECS with the new image
          terraform plan -input=false -lock-timeout=20m \
            -target=module.ecs \
            -out=app.tfplan

          terraform apply -input=false -lock-timeout=20m app.tfplan

      - name: Wait for Deployment
        run: |
          echo "Waiting for deployment to complete..."
          MAX_ATTEMPTS=40  # 20 minutes total
          ATTEMPTS=0
          DEPLOYMENT_DONE=false
          GRACE_PERIOD=180  # 3 minutes for container health

          function check_container_health() {
            local TASK_ARN=$1
            local CONTAINER_NAME=$2

            HEALTH_STATUS=$(aws ecs describe-tasks \
              --cluster "vimbiso-pay-cluster-$ENVIRONMENT" \
              --tasks "$TASK_ARN" \
              --query "tasks[0].containers[?name=='$CONTAINER_NAME'].healthStatus" \
              --output text)

            echo "$HEALTH_STATUS"
          }

          function get_container_logs() {
            local TASK_ID=$1
            local CONTAINER_NAME=$2
            local START_TIME=$3
            local LINES=${4:-100}  # Default to 100 lines

            echo "${CONTAINER_NAME} Container Logs:"
            echo "===================="
            aws logs get-log-events \
              --log-group-name "/ecs/vimbiso-pay-$ENVIRONMENT" \
              --log-stream-name "$([ "$CONTAINER_NAME" = "redis" ] && echo "redis" || echo "vimbiso-pay-${ENVIRONMENT}")/${CONTAINER_NAME}/${TASK_ID}" \
              --start-time ${START_TIME}000 \
              --limit $LINES \
              --query 'events[].message' \
              --output text || echo "No ${CONTAINER_NAME} logs available"
          }

          function check_health_endpoint() {
            local ALB_DNS=$1
            local MAX_RETRIES=3  # Try health check up to 3 times
            local RETRY=0

            while [ $RETRY -lt $MAX_RETRIES ]; do
              echo "Health check attempt $((RETRY + 1))/$MAX_RETRIES..."
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "http://${ALB_DNS}/health/")

              if [ "$HTTP_CODE" = "200" ]; then
                echo "Health endpoint check passed!"
                return 0
              else
                echo "Health check failed with HTTP code: $HTTP_CODE"
                RETRY=$((RETRY + 1))
                [ $RETRY -lt $MAX_RETRIES ] && sleep 5
              fi
            done
            return 1
          }

          # Record deployment start time
          DEPLOY_START_TIME=$(date +%s)

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            CURRENT_TIME=$(date +%s)
            ELAPSED_TIME=$((CURRENT_TIME - DEPLOY_START_TIME))

            SERVICE_JSON=$(aws ecs describe-services \
              --cluster "vimbiso-pay-cluster-$ENVIRONMENT" \
              --service "vimbiso-pay-service-$ENVIRONMENT" \
              --query 'services[0]')

            PRIMARY_DEPLOYMENT=$(echo $SERVICE_JSON | jq -r '.deployments[] | select(.status == "PRIMARY")')
            RUNNING_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.runningCount')
            DESIRED_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.desiredCount')
            FAILED_TASKS=$(echo $PRIMARY_DEPLOYMENT | jq -r '.failedTasks')
            PENDING_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.pendingCount')

            echo "Deployment Status (Elapsed: ${ELAPSED_TIME}s):"
            echo "  Running Count: $RUNNING_COUNT"
            echo "  Desired Count: $DESIRED_COUNT"
            echo "  Failed Tasks: $FAILED_TASKS"
            echo "  Pending Count: $PENDING_COUNT"

            # Get all running tasks
            RUNNING_TASKS=$(aws ecs list-tasks \
              --cluster "vimbiso-pay-cluster-$ENVIRONMENT" \
              --service-name "vimbiso-pay-service-$ENVIRONMENT" \
              --desired-status RUNNING \
              --query 'taskArns[]' \
              --output text)

            # Check health status of running tasks
            ALL_CONTAINERS_HEALTHY=true
            if [ ! -z "$RUNNING_TASKS" ]; then
              echo "Checking health of running tasks..."
              echo "$RUNNING_TASKS" | xargs -n1 | while read -r TASK_ARN; do
                if [ ! -z "$TASK_ARN" ]; then
                  TASK_ID=$(echo "$TASK_ARN" | awk -F'/' '{print $NF}')

                  # Check Redis health
                  REDIS_HEALTH=$(check_container_health "$TASK_ARN" "redis")
                  echo "Redis Health Status: $REDIS_HEALTH"

                  # Check App health
                  APP_HEALTH=$(check_container_health "$TASK_ARN" "vimbiso-pay-${ENVIRONMENT}")
                  echo "App Health Status: $APP_HEALTH"

                  if [ "$REDIS_HEALTH" != "HEALTHY" ] || [ "$APP_HEALTH" != "HEALTHY" ]; then
                    ALL_CONTAINERS_HEALTHY=false
                    # Only fail if past grace period
                    if [ $ELAPSED_TIME -gt $GRACE_PERIOD ]; then
                      echo "Unhealthy containers detected after grace period. Fetching logs..."
                      START_TIME=$(($(date +%s) - 300))
                      get_container_logs "$TASK_ID" "redis" "$START_TIME" 200
                      get_container_logs "$TASK_ID" "vimbiso-pay-${ENVIRONMENT}" "$START_TIME" 200
                      exit 1
                    fi
                  fi
                fi
              done
            fi

            if [ "$FAILED_TASKS" -gt 0 ]; then
              echo "Failed tasks detected. Fetching logs..."
              TASKS=$(aws ecs list-tasks \
                --cluster "vimbiso-pay-cluster-$ENVIRONMENT" \
                --service-name "vimbiso-pay-service-$ENVIRONMENT" \
                --desired-status STOPPED \
                --query 'taskArns[]' \
                --output text)

              if [ ! -z "$TASKS" ]; then
                echo "Found stopped tasks: $TASKS"
                echo "$TASKS" | xargs -n1 | while read -r TASK_ARN; do
                  if [ ! -z "$TASK_ARN" ]; then
                    TASK_ID=$(echo "$TASK_ARN" | awk -F'/' '{print $NF}')
                    START_TIME=$(($(date +%s) - 300))
                    get_container_logs "$TASK_ID" "redis" "$START_TIME" 200
                    get_container_logs "$TASK_ID" "vimbiso-pay-${ENVIRONMENT}" "$START_TIME" 200
                  fi
                done
              fi
              # Only fail if past grace period
              if [ $ELAPSED_TIME -gt $GRACE_PERIOD ]; then
                echo "Deployment failed due to task failures after grace period"
                exit 1
              fi
            fi

            # If containers are healthy and tasks are running, check health endpoint
            if [ "$ALL_CONTAINERS_HEALTHY" = true ] && \
               [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && \
               [ "$DESIRED_COUNT" -gt 0 ] && \
               [ "$PENDING_COUNT" = "0" ]; then

              echo "All containers healthy, verifying health endpoint..."
              ALB_DNS=$(cd terraform && terraform output -raw alb_dns_name)

              if check_health_endpoint "$ALB_DNS"; then
                DEPLOYMENT_DONE=true
                break
              else
                # Get logs from running tasks
                if [ ! -z "$RUNNING_TASKS" ]; then
                  echo "$RUNNING_TASKS" | xargs -n1 | while read -r TASK_ARN; do
                    TASK_ID=$(echo "$TASK_ARN" | awk -F'/' '{print $NF}')
                    START_TIME=$(($(date +%s) - 300))
                    get_container_logs "$TASK_ID" "redis" "$START_TIME" 200
                    get_container_logs "$TASK_ID" "vimbiso-pay-${ENVIRONMENT}" "$START_TIME" 200
                  done
                fi
                exit 1
              fi
            fi

            ATTEMPTS=$((ATTEMPTS + 1))
            if [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; then
              echo "Waiting 30 seconds... (Attempt $ATTEMPTS/$MAX_ATTEMPTS)"
              sleep 30
            fi
          done

          if [ "$DEPLOYMENT_DONE" != "true" ]; then
            echo "Deployment timeout after $(($MAX_ATTEMPTS * 30)) seconds"
            exit 1
          fi

      - name: Print Deployment Information
        run: |
          cd terraform
          echo "Deployment Summary"
          echo "=================="
          echo "Environment: $ENVIRONMENT"
          echo "Domain: $(terraform output -raw domain_name)"
          echo "ALB DNS: $(terraform output -raw alb_dns_name)"
          echo "ECS Cluster: $(terraform output -raw ecs_cluster_name)"
          echo "ECS Service: $(terraform output -raw ecs_service_name)"
          echo "NS Records:"
          terraform output -json route53_nameservers | jq -r '.[]' | sed 's/^/- /'

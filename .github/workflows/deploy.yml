name: Deploy VimbisoPay

on:
  push:
    branches:
      - stage  # Automatically trigger on push to stage branch
  workflow_dispatch:  # Manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/prod' || github.ref == 'refs/heads/stage'
    environment: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
    timeout-minutes: 30  # Add overall job timeout

    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
      BUILD_TARGET: production
      DOMAIN: ${{ github.ref == 'refs/heads/prod' && 'whatsapp.vimbisopay.africa' || 'stage.whatsapp.vimbisopay.africa' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: af-south-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Setup and Initialize Terraform Backend
        id: init-backend
        run: |
          echo "Current environment: ${ENVIRONMENT}"

          # Get AWS Account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          # Use AWS Account ID in bucket and table names
          BUCKET_NAME="vimbiso-pay-terraform-state-${ENVIRONMENT}-${AWS_ACCOUNT_ID}"
          TABLE_NAME="vimbiso-pay-terraform-state-lock-${ENVIRONMENT}-${AWS_ACCOUNT_ID}"

          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket: $BUCKET_NAME"
            aws s3api create-bucket --bucket "$BUCKET_NAME" --create-bucket-configuration LocationConstraint=af-south-1
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'
          else
            echo "S3 bucket already exists: $BUCKET_NAME"
          fi

          if ! aws dynamodb describe-table --table-name "$TABLE_NAME" >/dev/null 2>&1; then
            echo "Creating DynamoDB table: $TABLE_NAME"
            aws dynamodb create-table --table-name "$TABLE_NAME" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --tags Key=Environment,Value=${ENVIRONMENT} Key=ManagedBy,Value=terraform
          else
            echo "DynamoDB table already exists: $TABLE_NAME"
          fi

          cd terraform
          terraform init \
            -backend-config="bucket=${BUCKET_NAME}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=af-south-1" \
            -backend-config="dynamodb_table=${TABLE_NAME}"

          # Export the table name for use in other steps
          echo "dynamodb_table=${TABLE_NAME}" >> $GITHUB_OUTPUT

      - name: Clear Stale Locks
        env:
          DYNAMODB_TABLE: ${{ steps.init-backend.outputs.dynamodb_table }}
        run: |
          echo "Checking for stale locks..."

          # Get all locks with full details
          LOCKS_JSON=$(aws dynamodb scan --table-name "$DYNAMODB_TABLE" --output json)

          if [ ! -z "$LOCKS_JSON" ] && [ "$LOCKS_JSON" != "null" ]; then
            echo "Found locks, analyzing..."
            cd terraform

            # Parse the JSON and extract lock IDs
            echo "$LOCKS_JSON" | jq -r '.Items[] | select(.LockID != null) | .LockID.S' | while read -r LOCK_ID; do
              if [ ! -z "$LOCK_ID" ]; then
                echo "Found lock: $LOCK_ID"

                # Get lock info
                LOCK_INFO=$(aws dynamodb get-item \
                  --table-name "$DYNAMODB_TABLE" \
                  --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
                  --output json)

                if [ ! -z "$LOCK_INFO" ] && [ "$LOCK_INFO" != "null" ]; then
                  echo "Lock info: $LOCK_INFO"

                  # Extract the actual state path from the lock ID
                  STATE_PATH=$(echo "$LOCK_ID" | sed 's/-md5$//')

                  echo "Attempting to clear lock for state: $STATE_PATH"
                  terraform force-unlock -force "$STATE_PATH" || {
                    echo "Warning: Failed to clear lock via terraform, attempting direct DynamoDB removal"
                    aws dynamodb delete-item \
                      --table-name "$DYNAMODB_TABLE" \
                      --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
                      --return-values ALL_OLD
                  }
                else
                  echo "Warning: Could not get lock info for $LOCK_ID"
                fi
              fi
            done
          else
            echo "No locks found in DynamoDB table"
          fi

      - name: Check and Clean DNS Setup
        id: dns-check
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          # Add dummy values for required variables during DNS setup
          TF_VAR_docker_image: "dummy-image:latest"
          TF_VAR_django_secret: "dummy-secret"
          TF_VAR_mycredex_app_url: "https://dummy-url"
          TF_VAR_client_api_key: "dummy-key"
          TF_VAR_whatsapp_api_url: "https://dummy-url"
          TF_VAR_whatsapp_access_token: "dummy-token"
          TF_VAR_whatsapp_phone_number_id: "dummy-id"
          TF_VAR_whatsapp_business_id: "dummy-id"
          TF_VAR_whatsapp_registration_flow_id: "dummy-id"
          TF_VAR_whatsapp_company_registration_flow_id: "dummy-id"
        run: |
          cd terraform

          echo "Checking for existing resources..."

          # Check for existing hosted zone
          HOSTED_ZONE_ID=$(aws route53 list-hosted-zones-by-name \
            --dns-name "${DOMAIN}." \
            --max-items 1 \
            --query 'HostedZones[?Name==`'${DOMAIN}'.`].Id' \
            --output text)

          # Check for existing certificates
          CERT_ARN=$(aws acm list-certificates \
            --query "CertificateSummaryList[?DomainName=='${DOMAIN}'].CertificateArn" \
            --output text)

          # Check for existing validation records
          VALIDATION_RECORDS=""
          if [ ! -z "$HOSTED_ZONE_ID" ]; then
            ZONE_ID=${HOSTED_ZONE_ID#/hostedzone/}
            VALIDATION_RECORDS=$(aws route53 list-resource-record-sets \
              --hosted-zone-id $ZONE_ID \
              --query "ResourceRecordSets[?Type=='CNAME' && starts_with(Name, '_')].Name" \
              --output text)
          fi

          if [ ! -z "$HOSTED_ZONE_ID" ] || [ ! -z "$CERT_ARN" ] || [ ! -z "$VALIDATION_RECORDS" ]; then
            echo "Found existing resources. Cleaning up..."

            # Clean up any existing validation records first
            if [ ! -z "$VALIDATION_RECORDS" ]; then
              echo "Cleaning up validation records..."
              for record in $VALIDATION_RECORDS; do
                aws route53 change-resource-record-sets \
                  --hosted-zone-id $ZONE_ID \
                  --change-batch "{\"Changes\":[{\"Action\":\"DELETE\",\"ResourceRecordSet\":{\"Name\":\"$record\",\"Type\":\"CNAME\",\"TTL\":60}}]}" || true
              done
            fi

            # Delete any existing certificates
            if [ ! -z "$CERT_ARN" ]; then
              echo "Deleting certificate..."
              aws acm delete-certificate --certificate-arn $CERT_ARN || true
            fi

            # Import and destroy hosted zone through Terraform
            if [ ! -z "$HOSTED_ZONE_ID" ]; then
              echo "Importing and destroying hosted zone..."
              ZONE_ID=${HOSTED_ZONE_ID#/hostedzone/}
              terraform import -input=false module.route53_dns.aws_route53_zone.app $ZONE_ID || true

              terraform destroy -input=false \
                -lock-timeout=20m \
                -target=module.route53_dns.aws_route53_zone.app \
                -auto-approve || {
                  echo "Warning: Terraform destroy failed, attempting direct cleanup..."
                  # Delete all record sets except NS and SOA
                  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID | \
                    jq -r '.ResourceRecordSets[] | select(.Type != "SOA" and .Type != "NS") |
                    {"Action": "DELETE", "ResourceRecordSet": .}' | \
                    jq -s '{"Changes": .}' > /tmp/changes.json
                  aws route53 change-resource-record-sets \
                    --hosted-zone-id $ZONE_ID \
                    --change-batch file:///tmp/changes.json || true

                  # Finally delete the hosted zone
                  aws route53 delete-hosted-zone --id $ZONE_ID || true
                }
            fi

            echo "Cleanup completed. Proceeding with fresh setup..."
            sleep 30  # Wait for DNS propagation
          fi

          echo "Creating Route53 zone..."
          # Create plan file for Route53 zone only
          terraform plan -input=false \
            -lock-timeout=20m \
            -target=module.route53_dns.aws_route53_zone.app \
            -out=dns.tfplan

          # Apply Route53 zone configuration to get NS records
          terraform apply -input=false -lock-timeout=20m dns.tfplan

          # Check if NS records exist
          NS_RECORDS=$(terraform output -json route53_nameservers 2>/dev/null)
          if [ $? -eq 0 ] && [ ! -z "$NS_RECORDS" ]; then
            echo "NS records found. Checking if they are configured in parent domain..."

            # Get the parent domain's NS records
            PARENT_DOMAIN="whatsapp.vimbisopay.africa"
            PARENT_NS=$(aws route53 list-resource-record-sets \
              --hosted-zone-id Z0431766U8KGKIFJOPNG \
              --query "ResourceRecordSets[?Name == '${DOMAIN}.']" \
              --output json)

            if [ -z "$PARENT_NS" ] || [ "$PARENT_NS" == "[]" ]; then
              echo "NS records not configured in parent domain. Creating GitHub issue..."

              # Create a GitHub issue with NS record information
              if [ "$GITHUB_TOKEN" != "" ]; then
                ISSUE_BODY="DNS Configuration Required for ${DOMAIN}

                Please configure the following NS records in the parent domain (${PARENT_DOMAIN}):

                $(echo "$NS_RECORDS" | jq -r '.[]' | sed 's/^/- /')

                Once these NS records are configured in the parent domain, please re-run this workflow."

                curl -X POST \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  https://api.github.com/repos/${{ github.repository }}/issues \
                  -d "{\"title\":\"DNS Configuration Required for ${DOMAIN}\",\"body\":\"$ISSUE_BODY\",\"labels\":[\"dns-setup\"]}"
              fi

              echo "first_run=true" >> $GITHUB_OUTPUT
              echo "Please configure NS records in the parent domain and re-run this workflow."
              exit 0
            else
              echo "NS records already configured in parent domain."
              echo "first_run=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "No NS records found. This is unexpected - check Route53 configuration."
            exit 1
          fi

      # Only continue with remaining deployment if NS records are configured
      - name: Create Base Infrastructure
        if: steps.dns-check.outputs.first_run != 'true'
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          # Add dummy values for required variables during base infrastructure creation
          TF_VAR_docker_image: "dummy-image:latest"
          TF_VAR_django_secret: "dummy-secret"
          TF_VAR_mycredex_app_url: "https://dummy-url"
          TF_VAR_client_api_key: "dummy-key"
          TF_VAR_whatsapp_api_url: "https://dummy-url"
          TF_VAR_whatsapp_access_token: "dummy-token"
          TF_VAR_whatsapp_phone_number_id: "dummy-id"
          TF_VAR_whatsapp_business_id: "dummy-id"
          TF_VAR_whatsapp_registration_flow_id: "dummy-id"
          TF_VAR_whatsapp_company_registration_flow_id: "dummy-id"
        run: |
          cd terraform
          # Create plan file for base infrastructure (networking, IAM, ECR)
          terraform plan -input=false \
            -lock-timeout=20m \
            -target=module.networking \
            -target=module.iam \
            -target=module.ecr \
            -out=base.tfplan

          # Apply base infrastructure
          terraform apply -input=false -lock-timeout=20m base.tfplan || {
            echo "Base infrastructure deployment failed"
            terraform force-unlock -force $(terraform workspace show)
            exit 1
          }

      - name: Configure Load Balancer
        if: steps.dns-check.outputs.first_run != 'true'
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          # Add dummy values for required variables during load balancer configuration
          TF_VAR_docker_image: "dummy-image:latest"
          TF_VAR_django_secret: "dummy-secret"
          TF_VAR_mycredex_app_url: "https://dummy-url"
          TF_VAR_client_api_key: "dummy-key"
          TF_VAR_whatsapp_api_url: "https://dummy-url"
          TF_VAR_whatsapp_access_token: "dummy-token"
          TF_VAR_whatsapp_phone_number_id: "dummy-id"
          TF_VAR_whatsapp_business_id: "dummy-id"
          TF_VAR_whatsapp_registration_flow_id: "dummy-id"
          TF_VAR_whatsapp_company_registration_flow_id: "dummy-id"
        run: |
          cd terraform
          # Create plan file for load balancer configuration
          terraform plan -input=false \
            -lock-timeout=20m \
            -target=module.loadbalancer \
            -out=lb.tfplan

          # Apply load balancer configuration
          terraform apply -input=false -lock-timeout=20m lb.tfplan || {
            echo "Load balancer configuration failed"
            terraform force-unlock -force $(terraform workspace show)
            exit 1
          }

      - name: Login to Amazon ECR
        if: steps.dns-check.outputs.first_run != 'true'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        if: steps.dns-check.outputs.first_run != 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: vimbiso-pay-${{ env.ENVIRONMENT }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Docker image with target $BUILD_TARGET..."
          docker build --no-cache --target $BUILD_TARGET \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          echo "Docker image built successfully."

          echo "Pushing image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "Image pushed successfully: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          echo "IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy Application
        if: steps.dns-check.outputs.first_run != 'true'
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_docker_image: ${{ env.IMAGE }}
          TF_VAR_django_secret: ${{ secrets.DJANGO_SECRET }}
          TF_VAR_mycredex_app_url: ${{ secrets.MYCREDEX_APP_URL }}
          TF_VAR_client_api_key: ${{ secrets.CLIENT_API_KEY }}
          TF_VAR_whatsapp_api_url: ${{ secrets.WHATSAPP_API_URL }}
          TF_VAR_whatsapp_access_token: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
          TF_VAR_whatsapp_phone_number_id: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
          TF_VAR_whatsapp_business_id: ${{ secrets.WHATSAPP_BUSINESS_ID }}
          TF_VAR_whatsapp_registration_flow_id: ${{ secrets.WHATSAPP_REGISTRATION_FLOW_ID }}
          TF_VAR_whatsapp_company_registration_flow_id: ${{ secrets.WHATSAPP_COMPANY_REGISTRATION_FLOW_ID }}
        run: |
          cd terraform
          # Create plan file for ECS deployment
          terraform plan -input=false \
            -lock-timeout=20m \
            -target=module.ecs \
            -target=module.efs \
            -out=app.tfplan || {
            echo "Application plan creation failed"
            terraform force-unlock -force $(terraform workspace show)
            exit 1
          }

          # Apply ECS deployment
          terraform apply -input=false -lock-timeout=20m app.tfplan || {
            echo "Application deployment failed"
            terraform force-unlock -force $(terraform workspace show)
            exit 1
          }

      - name: Cleanup on Failure
        if: failure()
        run: |
          cd terraform
          echo "Cleaning up any hanging locks..."
          terraform force-unlock -force $(terraform workspace show)

      - name: Wait for Deployment
        if: steps.dns-check.outputs.first_run != 'true'
        run: |
          echo "Waiting for deployment to complete..."
          MAX_ATTEMPTS=40  # 20 minutes total (30 seconds * 40)
          ATTEMPTS=0
          DEPLOYMENT_DONE=false

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            SERVICE_JSON=$(aws ecs describe-services \
              --cluster vimbiso-pay-cluster-$ENVIRONMENT \
              --services vimbiso-pay-service-$ENVIRONMENT \
              --query 'services[0]')

            PRIMARY_DEPLOYMENT=$(echo $SERVICE_JSON | jq -r '.deployments[] | select(.status == "PRIMARY")')
            RUNNING_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.runningCount')
            DESIRED_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.desiredCount')
            FAILED_TASKS=$(echo $PRIMARY_DEPLOYMENT | jq -r '.failedTasks')
            PENDING_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.pendingCount')

            echo "Deployment Status:"
            echo "Running Count: $RUNNING_COUNT"
            echo "Desired Count: $DESIRED_COUNT"
            echo "Pending Count: $PENDING_COUNT"
            echo "Failed Tasks: $FAILED_TASKS"

            # Check for failed tasks first
            if [ "$FAILED_TASKS" -gt 0 ]; then
              echo "Error: Failed tasks detected during deployment"
              TASKS=$(aws ecs list-tasks \
                --cluster vimbiso-pay-cluster-$ENVIRONMENT \
                --services vimbiso-pay-service-$ENVIRONMENT \
                --desired-status STOPPED \
                --query 'taskArns[]' --output text)

              for TASK in $TASKS; do
                TASK_ID=${TASK##*/}
                echo "Failed task details for $TASK_ID:"

                # Get task details including stopped reason
                aws ecs describe-tasks \
                  --cluster vimbiso-pay-cluster-$ENVIRONMENT \
                  --tasks $TASK \
                  --query 'tasks[].{reason: stoppedReason, containers: containers[].{name: name, exitCode: exitCode, reason: reason}}' \
                  --output json

                # Get application logs
                echo "App logs for failed task $TASK_ID:"
                aws logs get-log-events \
                  --log-group-name "/ecs/vimbiso-pay-$ENVIRONMENT" \
                  --log-stream-name "app/$TASK_ID" \
                  --limit 100 \
                  --query 'events[].message' \
                  --output text || echo "No app logs available"

                # Get Redis logs
                echo "Redis logs for failed task $TASK_ID:"
                aws logs get-log-events \
                  --log-group-name "/ecs/vimbiso-pay-$ENVIRONMENT" \
                  --log-stream-name "redis/$TASK_ID" \
                  --limit 100 \
                  --query 'events[].message' \
                  --output text || echo "No Redis logs available"
              done

              echo "Recent service events:"
              echo $SERVICE_JSON | jq -r '.events[0:5][] | .message'
              exit 1
            fi

            # Check if deployment is complete
            if [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && [ "$DESIRED_COUNT" -gt 0 ] && [ "$PENDING_COUNT" = "0" ] && [ "$FAILED_TASKS" = "0" ]; then
              echo "Deployment completed successfully!"
              DEPLOYMENT_DONE=true
              break
            fi

            echo "Recent Events:"
            echo $SERVICE_JSON | jq -r '.events[0:3][] | .message'

            ATTEMPTS=$((ATTEMPTS + 1))
            if [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; then
              echo "Waiting 30 seconds before next check (Attempt $ATTEMPTS of $MAX_ATTEMPTS)..."
              sleep 30
            fi
          done

          if [ "$DEPLOYMENT_DONE" != "true" ]; then
            echo "Deployment did not complete within expected time"
            exit 1
          fi

      - name: Print Deployment Information
        if: steps.dns-check.outputs.first_run != 'true'
        run: |
          cd terraform
          echo "Deployment completed successfully."
          echo "Environment: $ENVIRONMENT"
          echo "Image: $IMAGE"
          echo "Build Target: $BUILD_TARGET"
          echo "========================================"
          echo "Infrastructure Outputs:"
          echo "========================================"
          echo "VPC ID: $(terraform output -raw vpc_id)"
          echo "Private Subnet IDs: $(terraform output -json private_subnet_ids)"
          echo "Public Subnet IDs: $(terraform output -json public_subnet_ids)"
          echo "ECR Repository URL: $(terraform output -raw ecr_repository_url)"
          echo "Domain: $(terraform output -raw domain_name)"
          echo "========================================"
          echo "Application Outputs:"
          echo "========================================"
          echo "ECS Cluster ARN: $(terraform output -raw ecs_cluster_arn)"
          echo "ECS Service Name: $(terraform output -raw ecs_service_name)"
          echo "ECS Task Definition ARN: $(terraform output -raw ecs_task_definition_arn)"
          echo "Auto Scaling Min Capacity: $(terraform output -raw autoscaling_target_min_capacity)"
          echo "Auto Scaling Max Capacity: $(terraform output -raw autoscaling_target_max_capacity)"
          echo "========================================"

name: Deploy Application

on:
  workflow_dispatch:

jobs:
  deploy_application:
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}

    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
      BUILD_TARGET: ${{ github.ref == 'refs/heads/prod' && 'production' || 'staging' }}
      DOMAIN: ${{ github.ref == 'refs/heads/prod' && 'mycredex.app' || 'stage.mycredex.dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: af-south-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Init
        run: |
          cd terraform
          echo "Current environment: ${ENVIRONMENT}"
          terraform init \
            -backend-config="bucket=vimbiso-pay-terraform-state-${ENVIRONMENT}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=af-south-1" \
            -backend-config="dynamodb_table=vimbiso-pay-terraform-state-lock-${ENVIRONMENT}"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: vimbiso-pay-${{ env.ENVIRONMENT }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building Docker image with target $BUILD_TARGET..."
          docker build --no-cache --target $BUILD_TARGET \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          echo "Docker image built successfully."

          echo "Pushing image to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "Image pushed successfully: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          echo "IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Terraform Plan
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_docker_image: ${{ env.IMAGE }}
          TF_VAR_django_secret: ${{ secrets.DJANGO_SECRET }}
          TF_VAR_mycredex_app_url: ${{ secrets.MYCREDEX_APP_URL }}
          TF_VAR_whatsapp_bot_api_key: ${{ secrets.WHATSAPP_BOT_API_KEY }}
          TF_VAR_whatsapp_api_url: ${{ secrets.WHATSAPP_API_URL }}
          TF_VAR_whatsapp_access_token: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
          TF_VAR_whatsapp_phone_number_id: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
        run: |
          cd terraform
          echo "Current environment: ${ENVIRONMENT}"
          echo "Planning Terraform changes..."
          terraform plan -input=false -out=tfplan -target=module.app

      - name: Terraform Apply
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_docker_image: ${{ env.IMAGE }}
          TF_VAR_django_secret: ${{ secrets.DJANGO_SECRET }}
          TF_VAR_mycredex_app_url: ${{ secrets.MYCREDEX_APP_URL }}
          TF_VAR_whatsapp_bot_api_key: ${{ secrets.WHATSAPP_BOT_API_KEY }}
          TF_VAR_whatsapp_api_url: ${{ secrets.WHATSAPP_API_URL }}
          TF_VAR_whatsapp_access_token: ${{ secrets.WHATSAPP_ACCESS_TOKEN }}
          TF_VAR_whatsapp_phone_number_id: ${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
        run: |
          cd terraform
          echo "Current environment: ${ENVIRONMENT}"
          echo "Applying Terraform changes..."
          terraform apply -auto-approve -input=false tfplan

      - name: Wait for Deployment
        run: |
          echo "Waiting for deployment to complete..."
          MAX_ATTEMPTS=40  # 20 minutes total (30 seconds * 40)
          ATTEMPTS=0
          DEPLOYMENT_DONE=false

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            # Get service details
            SERVICE_JSON=$(aws ecs describe-services \
              --cluster vimbiso-pay-cluster-$ENVIRONMENT \
              --services vimbiso-pay-service-$ENVIRONMENT \
              --query 'services[0]')
            
            # Get primary deployment status
            PRIMARY_DEPLOYMENT=$(echo $SERVICE_JSON | jq -r '.deployments[] | select(.status == "PRIMARY")')
            RUNNING_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.runningCount')
            DESIRED_COUNT=$(echo $PRIMARY_DEPLOYMENT | jq -r '.desiredCount')
            FAILED_TASKS=$(echo $PRIMARY_DEPLOYMENT | jq -r '.failedTasks')
            
            echo "Deployment Status:"
            echo "Running Count: $RUNNING_COUNT"
            echo "Desired Count: $DESIRED_COUNT"
            echo "Failed Tasks: $FAILED_TASKS"
            
            if [[ "$RUNNING_COUNT" == "$DESIRED_COUNT" && "$DESIRED_COUNT" -gt 0 ]]; then
              echo "Deployment completed successfully!"
              DEPLOYMENT_DONE=true
              break
            elif [[ "$FAILED_TASKS" -gt 0 ]]; then
              # Get task details and logs for debugging
              TASKS=$(aws ecs list-tasks \
                --cluster vimbiso-pay-cluster-$ENVIRONMENT \
                --service-name vimbiso-pay-service-$ENVIRONMENT \
                --desired-status STOPPED \
                --query 'taskArns[]' --output text)
              
              for TASK in $TASKS; do
                echo "Failed task details for $TASK:"
                aws ecs describe-tasks \
                  --cluster vimbiso-pay-cluster-$ENVIRONMENT \
                  --tasks $TASK \
                  --query 'tasks[].{reason: stoppedReason, exitCode: containers[].exitCode}'
                
                # Try to get logs even if task failed
                echo "Logs for failed task $TASK:"
                aws logs get-log-events \
                  --log-group-name "/ecs/vimbiso-pay-$ENVIRONMENT" \
                  --log-stream-name "vimbiso-pay-$ENVIRONMENT/${TASK##*/}" \
                  --limit 20 \
                  --query 'events[].message' \
                  --output text || echo "No logs available"
              done
              
              echo "Deployment failed due to task failures"
              exit 1
            fi
            
            # Get recent service events
            echo "Recent Events:"
            echo $SERVICE_JSON | jq -r '.events[0:3][] | .message'
            
            ATTEMPTS=$((ATTEMPTS + 1))
            if [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; then
              echo "Waiting 30 seconds before next check (Attempt $ATTEMPTS of $MAX_ATTEMPTS)..."
              sleep 30
            fi
          done

          if [ "$DEPLOYMENT_DONE" != "true" ]; then
            echo "Deployment did not complete within expected time"
            exit 1
          fi

      - name: Print Deployment Information
        run: |
          cd terraform
          echo "Deployment completed successfully."
          echo "Environment: $ENVIRONMENT"
          echo "Image: $IMAGE"
          echo "Build Target: $BUILD_TARGET"
          echo "========================================"
          echo "Application Outputs:"
          echo "========================================"
          echo "ECS Cluster ARN: $(terraform output -raw ecs_cluster_arn)"
          echo "ECS Service Name: $(terraform output -raw ecs_service_name)"
          echo "ECS Task Definition ARN: $(terraform output -raw ecs_task_definition_arn)"
          echo "Domain: $(terraform output -raw domain)"
          echo "Auto Scaling Config: $(terraform output -json autoscaling_config)"
          echo "========================================"
